# 커피 주문 앱

## 1. 프로젝트 개요

### 1.1 프로젝트명
커피 주문 앱

### 1.2 프로젝트 목적
사용자가 커피 메뉴를 주문하고, 관리자가 주문을 관리할 수 있는 간단한 풀스택 웹 앱

### 1.3 개발 범위
- 주문하기 화면(메뉴 선택 및 장바구니 기능)
- 관리자 화면(재고 관리 및 주문 상태 관리)
- 데이터를 생성/조회/수정/삭제할 수 있는 기능

## 2. 기술 스택
- 프론트엔드: HTML, CSS, 리액트, 자바스크립트
- 백엔드: Node.js, Express
- 데이터베이스: PostgreSQL

## 3. 기본 사항
- 프런트엔드와 백엔드를 따로 개발
- 기본적인 웹 기술만 사용
- 학습 목적이므로 사용자 인증이나 결제 기능은 제외
- 메뉴는 커피 메뉴만 있음

## 4. 주문하기 화면 상세 요구사항

### 4.1 화면 개요
주문하기 화면은 사용자가 커피 메뉴를 선택하고 옵션을 커스터마이징한 후 장바구니에 담아 주문할 수 있는 화면입니다.

### 4.2 화면 구조
주문하기 화면은 다음과 같은 세 가지 주요 섹션으로 구성됩니다:
1. 헤더 섹션 - 로고 및 네비게이션
2. 메뉴 아이템 섹션 - 메뉴 목록 및 옵션 선택
3. 장바구니 섹션 - 선택한 메뉴 목록 및 주문하기

### 4.3 헤더 섹션

#### 4.3.1 구성 요소
- **로고 영역**: 좌측에 "COZY" 텍스트가 포함된 다크 배경의 사각형 박스
  - 위치: 헤더 좌측
  - 배경색: 다크 그린 또는 다크 그레이
  - 텍스트: "COZY" (흰색)
  - 텍스트 크기: 중간 크기, 굵게 표시
- **주문하기 버튼**: 헤더 우측에 위치
  - 텍스트: "주문하기"
  - 현재 화면이므로 활성화 상태 또는 하이라이트 표시 가능
- **관리자 버튼**: 헤더 우측에 위치 (주문하기 버튼 옆)
  - 텍스트: "관리자"
  - 클릭 시 관리자 화면으로 이동

#### 4.3.2 레이아웃
- 헤더는 화면 상단에 고정
- 로고와 버튼들은 수평으로 배치
- 로고는 좌측 정렬, 버튼들은 우측 정렬
- 헤더 전체에 하단 구분선 또는 그림자 추가 가능 (선택적)

#### 4.3.3 기능 요구사항
- 관리자 버튼 클릭 시 관리자 화면으로 라우팅
- 주문하기 버튼은 현재 화면을 나타내는 표시용 (비활성화 또는 스타일 차별화)

### 4.4 메뉴 아이템 섹션

#### 4.4.1 레이아웃
- 메뉴 아이템들은 카드 형태로 가로로 배치 (그리드 레이아웃)
- 각 카드는 동일한 구조와 스타일을 가짐
- 카드 사이에 적절한 간격 유지
- 반응형 디자인: 화면 크기에 따라 한 줄에 표시되는 카드 개수 조정
  - 데스크톱: 3개 이상
  - 태블릿: 2-3개
  - 모바일: 1-2개

#### 4.4.2 메뉴 카드 구성 요소
각 메뉴 카드는 흰색 배경에 테두리가 있는 사각형 형태이며, 다음 요소들을 포함합니다:

1. **이미지 영역**
   - 카드 상단에 위치
   - 메뉴 이미지를 표시하는 직사각형 영역
   - 이미지가 없는 경우 플레이스홀더 표시
     - 흰색 배경에 대각선 두 개가 그어진 형태 (X 모양)
     - 대각선 색상: 연한 회색
   - 이미지 비율: 가로가 세로보다 약간 긴 직사각형

2. **메뉴 정보**
   - **메뉴명**: 메뉴의 이름
     - 위치: 이미지 영역 바로 아래
     - 스타일: 중간 크기, 굵게 표시
     - 예시: "아메리카노(ICE)", "아메리카노(HOT)", "카페라떼"
   
   - **가격**: 기본 가격
     - 위치: 메뉴명 아래
     - 형식: "{금액}원"
     - 예시: "4,000원", "5,000원"
   
   - **설명**: 메뉴에 대한 간단한 설명 텍스트
     - 위치: 가격 아래
     - 스타일: 작은 크기, 연한 회색
     - 예시: "간단한 설명..."
     - 길이: 1-2줄 제한

3. **커스터마이징 옵션**
   - 위치: 설명 아래, 체크박스 리스트 형태
   - 각 옵션은 체크박스와 레이블로 구성
   - 옵션 레이블 형식: "{옵션명} (+{추가금액}원)" 또는 "(+{추가금액}원)"
   - 예시 옵션:
     - ☐ 샷 추가 (+500원)
     - ☐ 시럽 추가 (+0원)
   - 기능:
     - 여러 옵션을 동시에 선택 가능 (다중 선택)
     - 체크박스 클릭 시 선택/해제 토글
     - 선택된 옵션은 체크 표시 (☑)
     - 옵션 선택 시 실시간으로 총 가격 계산 (내부적으로)

4. **담기 버튼**
   - 위치: 카드 하단
   - 스타일:
     - 배경색: 회색 (#E0E0E0 또는 유사한 색상)
     - 텍스트: "담기" (중앙 정렬)
     - 텍스트 색상: 다크 그레이 또는 검정
     - 너비: 카드 너비에 맞춤 (좌우 여백 유지)
     - 모서리: 약간 둥글게 처리 (선택적)
   - 상태:
     - 기본 상태: 회색 배경
     - 호버 상태: 배경색 약간 어둡게 (선택적)
     - 클릭 상태: 약간 눌린 효과 (선택적)

#### 4.4.3 메뉴 카드 스타일
- 배경: 흰색
- 테두리: 연한 회색 (1px)
- 모서리: 약간 둥글게 처리 (선택적)
- 그림자: 미세한 그림자 효과 (선택적)
- 패딩: 카드 내부에 적절한 여백
- 카드 크기: 고정된 너비 또는 유연한 너비 (반응형)

#### 4.4.4 기능 요구사항
- **메뉴 로드**
  - 메뉴 목록은 백엔드 API를 통해 동적으로 로드
  - 로딩 중 스켈레톤 UI 또는 로딩 인디케이터 표시 (선택적)
  - API 요청 실패 시 에러 메시지 표시

- **옵션 선택**
  - 각 옵션의 체크박스 클릭 시 선택/해제 토글
  - 선택된 옵션은 시각적으로 표시 (체크 표시)
  - 여러 옵션 동시 선택 가능
  - 옵션 선택 시 내부적으로 총 가격 계산 (표시는 선택적)

- **담기 버튼 동작**
  - 클릭 시 다음 정보와 함께 장바구니에 추가:
    - 메뉴 ID
    - 메뉴명
    - 기본 가격
    - 선택된 옵션 배열 (옵션 ID, 이름, 가격)
    - 수량 (기본값: 1)
    - 총 가격 (기본 가격 + 옵션 가격의 합)
  
  - 장바구니 추가 로직:
    - 동일한 메뉴와 동일한 옵션 조합이 이미 장바구니에 있으면 수량만 1 증가
    - 메뉴가 같아도 옵션이 다르면 별도 아이템으로 추가
  
  - 사용자 피드백:
    - 장바구니에 추가되었음을 알리는 시각적 피드백 (선택적)
    - 예: 토스트 메시지, 버튼 애니메이션, 장바구니 하이라이트 등
  
  - 추가 후 옵션 선택 상태 초기화 (선택적)

- **재고 표시** (선택적)
  - 재고가 없는 메뉴는 비활성화 처리
  - "품절" 표시 또는 회색 처리
  - 담기 버튼 비활성화

### 4.5 장바구니 섹션

#### 4.5.1 레이아웃
- 위치: 메뉴 아이템 섹션 하단
- 배경: 연한 회색 또는 흰색
- 테두리: 연한 회색 (상단 구분선 또는 전체 테두리)
- 패딩: 내부에 적절한 여백
- 모서리: 약간 둥글게 처리 (선택적)

#### 4.5.2 구성 요소

1. **장바구니 제목**
   - 텍스트: "장바구니"
   - 위치: 섹션 최상단 좌측
   - 스타일: 중간 크기, 굵게 표시
   - 색상: 다크 그레이 또는 검정

2. **장바구니 아이템 목록**
   각 아이템은 다음 정보를 포함하는 한 줄로 표시:
   
   - **표시 형식**: "{메뉴명} ({옵션명}) X {수량}"
   - **가격**: 해당 아이템의 총 가격 (우측 정렬)
   
   - **예시**:
     ```
     아메리카노(ICE) (샷 추가)  X 1        4,500원
     아메리카노(HOT)  X 2                  8,000원
     ```
   
   - **레이아웃**:
     - 메뉴명 및 옵션 정보: 좌측 정렬
     - 가격: 우측 정렬
     - 항목들 사이에 적절한 간격 유지
   
   - **옵션 표시 규칙**:
     - 옵션이 선택된 경우: 괄호 안에 옵션명 표시
     - 여러 옵션이 선택된 경우: 쉼표로 구분하여 표시
     - 옵션이 없는 경우: 메뉴명만 표시
   
   - **삭제 기능** (선택적):
     - 각 아이템 옆에 삭제 버튼 추가 가능
     - 클릭 시 해당 아이템을 장바구니에서 제거

3. **총 금액**
   - **표시 형식**: "총 금액  {금액}원"
   - **위치**: 아이템 목록 아래
   - **레이아웃**:
     - "총 금액" 레이블: 좌측
     - 금액: 우측 정렬
   - **스타일**:
     - 텍스트 크기: 중간~큰 크기
     - 굵게 표시 (강조)
     - 색상: 검정 또는 다크 그레이
   - **예시**: "총 금액  12,500원"
   - **계산**: 모든 장바구니 아이템의 (기본가격 + 옵션가격) × 수량의 합계

4. **주문하기 버튼**
   - **위치**: 총 금액 아래 또는 우측
   - **텍스트**: "주문하기"
   - **스타일**:
     - 배경색: 회색 (#E0E0E0 또는 유사한 색상)
     - 텍스트 색상: 다크 그레이 또는 검정
     - 너비: 적절한 크기 (또는 전체 너비)
     - 모서리: 약간 둥글게 처리 (선택적)
   - **상태**:
     - 장바구니가 비어있을 경우: 비활성화 (회색 처리)
     - 장바구니에 아이템이 있을 경우: 활성화
     - 호버 상태: 배경색 약간 어둡게 (선택적)

#### 4.5.3 빈 장바구니 상태
- 장바구니가 비어있을 때:
  - 옵션 1: 장바구니 섹션 전체를 숨김
  - 옵션 2: "장바구니가 비어있습니다" 메시지 표시
  - 주문하기 버튼은 비활성화

#### 4.5.4 기능 요구사항

- **장바구니 상태 관리**
  - 장바구니 데이터는 클라이언트 상태로 관리 (React State, Context API 등)
  - 장바구니 아이템 추가/삭제 시 즉시 UI 업데이트
  - 총 금액 자동 재계산

- **가격 계산**
  - 각 아이템 가격 = (기본 가격 + 옵션 가격의 합) × 수량
  - 총 금액 = 모든 아이템 가격의 합
  - 가격은 1,000단위 구분 쉼표 표시 (예: "12,500원")

- **아이템 통합 규칙**
  - 동일한 메뉴 + 동일한 옵션 조합 = 수량으로 통합
  - 메뉴가 같아도 옵션이 다르면 별도 아이템으로 표시
  - 예시:
    - "아메리카노(ICE) (샷 추가)" x 2 → 한 줄로 표시
    - "아메리카노(ICE)" x 1 → 별도 줄로 표시

- **주문하기 버튼 동작**
  - 클릭 시:
    1. 장바구니 데이터 검증
    2. 주문 데이터 구성 (아이템 목록, 총 금액 등)
    3. 백엔드 API로 주문 데이터 전송 (POST 요청)
    4. 로딩 상태 표시 (버튼 비활성화 또는 로딩 인디케이터)
  
  - 주문 성공 시:
    - 장바구니 초기화 (모든 아이템 제거)
    - 성공 메시지 표시 (알림, 토스트 등)
    - 예: "주문이 완료되었습니다!"
  
  - 주문 실패 시:
    - 에러 메시지 표시
    - 장바구니 상태 유지 (사용자가 재시도 가능)
    - 예: "주문에 실패했습니다. 다시 시도해주세요."

- **아이템 삭제** (선택적 구현)
  - 각 아이템의 삭제 버튼 클릭 시:
    - 해당 아이템을 장바구니에서 제거
    - 총 금액 재계산
    - UI 즉시 업데이트

### 4.6 UI/UX 요구사항

#### 4.6.1 디자인 시스템
- **전체 배경**: 흰색 또는 매우 연한 회색 (#F5F5F5)
- **텍스트 색상**:
  - 주요 텍스트: 다크 그레이 (#333333) 또는 검정
  - 보조 텍스트: 연한 회색 (#757575)
- **강조 색상**: 
  - 로고 영역: 다크 그린 또는 다크 그레이
  - 활성화 상태: 다크 그린 또는 파란색 (선택적)
- **버튼 스타일**:
  - 기본 배경: 회색 (#E0E0E0)
  - 텍스트: 다크 그레이 또는 검정
  - 호버: 배경색 약간 어둡게
  - 비활성화: 연한 회색, 투명도 적용
- **테두리**: 연한 회색 (#DDDDDD 또는 #E0E0E0)
- **모서리**: 약간 둥글게 (border-radius: 4-8px)

#### 4.6.2 타이포그래피
- **폰트**: 시스템 기본 폰트 또는 한글 가독성 좋은 폰트 (나눔고딕, 맑은고딕 등)
- **크기**:
  - 헤더 로고: 18-24px, 굵게
  - 메뉴명: 16-18px, 굵게
  - 가격: 14-16px, 보통 또는 굵게
  - 설명: 12-14px, 보통
  - 옵션: 13-15px, 보통
  - 장바구니 아이템: 14-16px, 보통
  - 총 금액: 18-20px, 굵게

#### 4.6.3 간격 및 여백
- 섹션 간 여백: 24-32px
- 카드 간 여백: 16-24px
- 카드 내부 패딩: 16-20px
- 버튼 패딩: 12-16px (상하), 24-32px (좌우)

#### 4.6.4 사용자 피드백
- **버튼 클릭**:
  - 호버 효과: 배경색 변경 또는 그림자 추가
  - 클릭 효과: 버튼 크기 약간 축소 또는 배경색 더 어둡게
  
- **담기 버튼 클릭**:
  - 성공 시: 버튼 색상 변경 또는 체크 아이콘 표시 (짧은 시간)
  - 토스트 메시지: "장바구니에 추가되었습니다" (선택적)
  - 장바구니 섹션 하이라이트 또는 스크롤 (선택적)

- **체크박스 선택**:
  - 체크 표시: ☑ (파란색 또는 다크 그레이)
  - 미체크 표시: ☐ (회색)
  - 호버 시: 배경색 약간 변경

- **주문하기 버튼 클릭**:
  - 로딩 중: 버튼 비활성화 + 로딩 스피너 표시
  - 성공: 알림 메시지 또는 모달 표시
  - 실패: 에러 메시지 표시 (빨간색)

#### 4.6.5 로딩 상태
- **메뉴 로딩 중**:
  - 스켈레톤 UI: 카드 형태의 회색 박스 표시 (선택적)
  - 로딩 스피너: 화면 중앙에 표시
  - 로딩 텍스트: "메뉴를 불러오는 중..." (선택적)

- **주문 처리 중**:
  - 주문하기 버튼 비활성화
  - 버튼 내 로딩 스피너 표시
  - 또는 전체 화면 로딩 오버레이

#### 4.6.6 에러 처리
- **API 에러**:
  - 메뉴 로드 실패: "메뉴를 불러올 수 없습니다" 메시지 + 재시도 버튼
  - 주문 실패: "주문에 실패했습니다. 다시 시도해주세요" 메시지 (빨간색)

- **에러 메시지 표시 방법**:
  - 토스트 메시지 (화면 상단 또는 하단)
  - 알림 모달
  - 인라인 메시지 (해당 영역 내)

#### 4.6.7 반응형 디자인
- **데스크톱 (1024px 이상)**:
  - 메뉴 카드: 3-4개씩 가로 배치
  - 장바구니: 화면 하단에 고정 또는 우측에 배치 (선택적)

- **태블릿 (768px - 1023px)**:
  - 메뉴 카드: 2-3개씩 가로 배치
  - 헤더 버튼 크기 약간 조정

- **모바일 (767px 이하)**:
  - 메뉴 카드: 1-2개씩 가로 배치
  - 장바구니: 화면 하단에 고정
  - 주문하기 버튼: 전체 너비

#### 4.6.8 접근성 (선택적)
- 키보드 네비게이션 지원
- 포커스 표시: 파란색 테두리
- 대체 텍스트: 이미지에 alt 속성
- 적절한 색상 대비 (WCAG AA 이상)

### 4.7 데이터 구조

#### 4.7.1 메뉴 데이터 (백엔드 응답)
```javascript
{
  id: number,              // 메뉴 고유 ID
  name: string,            // 메뉴명 (예: "아메리카노(ICE)")
  price: number,           // 기본 가격 (예: 4000)
  description: string,     // 메뉴 설명 (예: "간단한 설명...")
  imageUrl: string,        // 이미지 URL (optional, 없으면 플레이스홀더 표시)
  stock: number,           // 재고 수량 (optional)
  options: [               // 옵션 목록
    {
      id: number,          // 옵션 고유 ID
      name: string,        // 옵션명 (예: "샷 추가")
      price: number        // 추가 가격 (예: 500)
    }
  ]
}
```

**예시**:
```json
{
  "id": 1,
  "name": "아메리카노(ICE)",
  "price": 4000,
  "description": "간단한 설명...",
  "imageUrl": null,
  "stock": 10,
  "options": [
    {
      "id": 1,
      "name": "샷 추가",
      "price": 500
    },
    {
      "id": 2,
      "name": "시럽 추가",
      "price": 0
    }
  ]
}
```

#### 4.7.2 장바구니 아이템 데이터 (클라이언트 상태)
```javascript
{
  menuId: number,          // 메뉴 ID
  menuName: string,        // 메뉴명
  basePrice: number,       // 기본 가격
  selectedOptions: [       // 선택된 옵션 배열
    {
      optionId: number,    // 옵션 ID
      optionName: string,  // 옵션명
      optionPrice: number  // 옵션 가격
    }
  ],
  quantity: number,        // 수량
  totalPrice: number       // 총 가격 (basePrice + 옵션 가격의 합) × quantity
}
```

**예시**:
```json
{
  "menuId": 1,
  "menuName": "아메리카노(ICE)",
  "basePrice": 4000,
  "selectedOptions": [
    {
      "optionId": 1,
      "optionName": "샷 추가",
      "optionPrice": 500
    }
  ],
  "quantity": 1,
  "totalPrice": 4500
}
```

#### 4.7.3 주문 데이터 (백엔드 전송)
```javascript
{
  items: [                 // 주문 아이템 배열
    {
      menuId: number,      // 메뉴 ID
      menuName: string,    // 메뉴명 (optional, 백엔드에서 참조용)
      quantity: number,    // 수량
      selectedOptions: [   // 선택된 옵션 ID 배열 또는 옵션 객체 배열
        {
          optionId: number,
          optionName: string,  // optional
          optionPrice: number  // optional
        }
      ],
      itemTotalPrice: number  // 아이템 총 가격 (검증용, optional)
    }
  ],
  totalAmount: number,     // 주문 총 금액
  orderDate: string        // 주문 일시 (ISO 8601, 클라이언트 또는 서버에서 생성)
}
```

**예시**:
```json
{
  "items": [
    {
      "menuId": 1,
      "menuName": "아메리카노(ICE)",
      "quantity": 1,
      "selectedOptions": [
        {
          "optionId": 1,
          "optionName": "샷 추가",
          "optionPrice": 500
        }
      ],
      "itemTotalPrice": 4500
    },
    {
      "menuId": 2,
      "menuName": "아메리카노(HOT)",
      "quantity": 2,
      "selectedOptions": [],
      "itemTotalPrice": 8000
    }
  ],
  "totalAmount": 12500,
  "orderDate": "2025-11-12T14:30:00Z"
}
```

#### 4.7.4 주문 응답 데이터 (백엔드 응답)
```javascript
{
  success: boolean,        // 주문 성공 여부
  orderId: number,         // 생성된 주문 ID
  message: string,         // 성공/실패 메시지 (optional)
  error: string            // 에러 메시지 (실패 시, optional)
}
```

**성공 예시**:
```json
{
  "success": true,
  "orderId": 123,
  "message": "주문이 완료되었습니다"
}
```

**실패 예시**:
```json
{
  "success": false,
  "error": "재고가 부족합니다"
}
```

### 4.8 API 엔드포인트

#### 4.8.1 메뉴 목록 조회
- **Method**: GET
- **Endpoint**: `/api/menus` 또는 `/api/menu-items`
- **설명**: 모든 메뉴 목록과 옵션을 조회
- **요청 파라미터**: 없음
- **응답**:
  ```javascript
  {
    success: boolean,
    data: [
      {
        id: number,
        name: string,
        price: number,
        description: string,
        imageUrl: string,
        stock: number,
        options: [
          {
            id: number,
            name: string,
            price: number
          }
        ]
      }
    ]
  }
  ```

#### 4.8.2 주문 생성
- **Method**: POST
- **Endpoint**: `/api/orders`
- **설명**: 새로운 주문을 생성
- **요청 본문**:
  ```javascript
  {
    items: [
      {
        menuId: number,
        quantity: number,
        selectedOptions: [
          {
            optionId: number
          }
        ]
      }
    ],
    totalAmount: number
  }
  ```
- **응답**:
  ```javascript
  {
    success: boolean,
    orderId: number,
    message: string
  }
  ```

### 4.9 구현 우선순위

#### 4.9.1 필수 기능 (MVP)
1. 헤더 네비게이션 (로고, 화면 전환 버튼)
2. 메뉴 카드 표시 (이미지, 이름, 가격, 설명)
3. 옵션 선택 기능 (체크박스)
4. 담기 버튼 (장바구니 추가)
5. 장바구니 아이템 목록 표시
6. 총 금액 계산 및 표시
7. 주문하기 버튼 (주문 생성 API 호출)
8. 기본 에러 처리

#### 4.9.2 권장 기능
1. 로딩 상태 표시
2. 주문 성공/실패 메시지
3. 장바구니 아이템 삭제 기능
4. 반응형 디자인
5. 호버 효과 및 피드백 애니메이션

#### 4.9.3 선택적 기능
1. 재고 부족 시 메뉴 비활성화
2. 스켈레톤 UI
3. 토스트 메시지
4. 장바구니 자동 스크롤
5. 주문 확인 모달
6. 접근성 (키보드 네비게이션)

### 4.10 개발 가이드라인

#### 4.10.1 컴포넌트 구조 (React 기준)
```
OrderPage/
├── Header
│   ├── Logo
│   └── Navigation
├── MenuSection
│   └── MenuCard (반복)
│       ├── MenuImage
│       ├── MenuInfo
│       ├── OptionList
│       │   └── OptionCheckbox (반복)
│       └── AddToCartButton
└── CartSection
    ├── CartTitle
    ├── CartItemList
    │   └── CartItem (반복)
    ├── TotalAmount
    └── OrderButton
```

#### 4.10.2 상태 관리
- **메뉴 데이터**: API에서 조회한 메뉴 목록 (useState 또는 전역 상태)
- **장바구니**: 선택된 아이템 배열 (useState 또는 Context API)
- **로딩 상태**: API 호출 중 여부 (useState)
- **에러 상태**: 에러 메시지 (useState)

#### 4.10.3 주요 함수
- `fetchMenus()`: 메뉴 목록 조회
- `addToCart(menu, options)`: 장바구니에 아이템 추가
- `removeFromCart(index)`: 장바구니 아이템 삭제
- `calculateTotal()`: 총 금액 계산
- `submitOrder()`: 주문 생성 API 호출
- `handleOptionChange(menuId, optionId)`: 옵션 선택/해제

#### 4.10.4 주의사항
- 옵션이 다르면 별도 아이템으로 처리
- 가격 계산 시 옵션 가격 누락 주의
- API 에러 처리 필수
- 장바구니 빈 상태 처리
- 수량은 항상 1 이상

---

## 5. 관리자 화면 상세 요구사항

### 5.1 화면 개요
관리자 화면은 관리자가 재고를 관리하고 주문 상태를 확인 및 변경할 수 있는 화면입니다.

### 5.2 화면 구조
관리자 화면은 다음과 같은 네 가지 주요 섹션으로 구성됩니다:
1. 헤더 섹션 - 로고 및 네비게이션
2. 관리자 대시보드 섹션 - 주문 통계 요약
3. 재고 현황 섹션 - 메뉴별 재고 관리
4. 주문 현황 섹션 - 주문 목록 및 상태 관리

### 5.3 헤더 섹션

#### 5.3.1 구성 요소
- **로고 영역**: 좌측에 "COZY" 텍스트가 포함된 다크 배경의 사각형 박스
  - 위치: 헤더 좌측
  - 배경색: 다크 그레이 또는 다크 그린
  - 텍스트: "COZY" (흰색)
  - 텍스트 크기: 중간 크기, 굵게 표시
  - 주문하기 화면의 로고와 동일한 스타일

- **주문하기 버튼**: 헤더 우측에 위치
  - 텍스트: "주문하기"
  - 클릭 시 주문하기 화면으로 이동
  - 스타일: 일반 상태 (테두리 없음 또는 연한 테두리)

- **관리자 버튼**: 헤더 우측에 위치 (주문하기 버튼 옆)
  - 텍스트: "관리자"
  - 현재 화면이므로 활성화 상태로 표시
  - 스타일: 
    - 테두리: 다크 그레이 또는 검정 (강조)
    - 배경: 흰색 또는 연한 회색
    - 또는 버튼 스타일을 다르게 하여 현재 화면임을 표시

#### 5.3.2 레이아웃
- 헤더는 화면 상단에 고정
- 로고와 버튼들은 수평으로 배치
- 로고는 좌측 정렬, 버튼들은 우측 정렬
- 헤더 전체에 하단 구분선 또는 그림자 추가 가능 (선택적)

#### 5.3.3 기능 요구사항
- 주문하기 버튼 클릭 시 주문하기 화면으로 라우팅
- 관리자 버튼은 현재 화면을 나타내는 표시용 (비활성화 또는 스타일 차별화)

### 5.4 관리자 대시보드 섹션

#### 5.4.1 레이아웃
- 위치: 헤더 바로 아래
- 배경: 연한 회색 또는 흰색 박스
- 테두리: 연한 회색 또는 없음
- 모서리: 약간 둥글게 처리 (선택적)
- 패딩: 내부에 적절한 여백

#### 5.4.2 구성 요소

1. **섹션 제목**
   - 텍스트: "관리자 대시보드"
   - 위치: 섹션 최상단 좌측
   - 스타일: 중간~큰 크기, 굵게 표시
   - 색상: 다크 그레이 또는 검정

2. **주문 통계**
   - **표시 형식**: "총 주문 {총 주문 수} / 주문 접수 {접수 수} / 제조 중 {제조 중 수} / 제조 완료 {완료 수}"
   - **위치**: 제목 아래
   - **스타일**:
     - 한 줄로 표시
     - 슬래시(/)로 구분
     - 텍스트 크기: 보통 크기
     - 색상: 다크 그레이
   - **예시**: 
     - "총 주문 1 / 주문 접수 1 / 제조 중 0 / 제조 완료 0"
     - "총 주문 5 / 주문 접수 2 / 제조 중 2 / 제조 완료 1"
   
   - **숫자 강조** (선택적):
     - 각 숫자를 굵게 표시하거나 다른 색상으로 강조
     - 예: "총 주문 **1** / 주문 접수 **1** / 제조 중 **0** / 제조 완료 **0**"

#### 5.4.3 기능 요구사항

- **데이터 로드**
  - 백엔드 API를 통해 주문 상태별 집계 데이터를 조회
  - API 엔드포인트: `/api/orders/statistics` 또는 `/api/admin/dashboard`
  - 화면 로드 시 자동으로 통계 조회

- **실시간 업데이트**
  - 주문 상태가 변경될 때마다 통계 자동 갱신
  - 주문 접수 버튼 클릭 후 통계 즉시 업데이트
  - 주기적으로 통계 갱신 (선택적: 30초~1분마다 자동 새로고침)

- **통계 계산**
  - **총 주문**: 모든 상태의 주문 수 합계
  - **주문 접수**: 상태가 "주문 접수"인 주문 수
  - **제조 중**: 상태가 "제조 중"인 주문 수
  - **제조 완료**: 상태가 "제조 완료"인 주문 수

- **에러 처리**
  - 통계 로드 실패 시: "통계를 불러올 수 없습니다" 메시지 표시
  - 재시도 버튼 제공 (선택적)

### 5.5 재고 현황 섹션

#### 5.5.1 레이아웃
- 위치: 관리자 대시보드 섹션 아래
- 배경: 연한 회색 또는 흰색 박스
- 테두리: 연한 회색
- 모서리: 약간 둥글게 처리 (선택적)
- 패딩: 내부에 적절한 여백

#### 5.5.2 섹션 제목
- 텍스트: "재고 현황"
- 위치: 섹션 최상단 좌측
- 스타일: 중간~큰 크기, 굵게 표시
- 색상: 다크 그레이 또는 검정

#### 5.5.3 재고 카드 레이아웃
- 재고 카드들은 가로로 배치 (그리드 레이아웃)
- 각 카드는 동일한 크기와 스타일
- 카드 사이에 적절한 간격 유지
- 반응형 디자인: 화면 크기에 따라 한 줄에 표시되는 카드 개수 조정
  - 데스크톱: 3-4개씩
  - 태블릿: 2-3개씩
  - 모바일: 1-2개씩

#### 5.5.4 재고 카드 구성 요소
각 재고 카드는 흰색 배경에 테두리가 있는 사각형 형태이며, 다음 요소들을 포함합니다:

1. **메뉴명**
   - 위치: 카드 상단
   - 텍스트: 메뉴 이름
   - 예시: "아메리카노 (ICE)", "아메리카노 (HOT)", "카페라떼"
   - 스타일:
     - 크기: 중간 크기, 굵게
     - 색상: 다크 그레이 또는 검정
     - 정렬: 중앙 또는 좌측

2. **재고 수량**
   - 위치: 메뉴명 아래
   - 형식: "{수량}개"
   - 예시: "10개", "5개", "0개"
   - 스타일:
     - 크기: 중간~큰 크기
     - 색상: 다크 그레이 또는 검정
     - 정렬: 중앙
   - 재고 부족 시 색상 변경 (선택적):
     - 재고 0개: 빨간색
     - 재고 3개 이하: 주황색

3. **재고 조정 버튼**
   - 위치: 재고 수량 아래
   - 레이아웃: 두 버튼을 가로로 나란히 배치
   
   - **증가 버튼 (+)**:
     - 텍스트: "+" 또는 "＋"
     - 스타일:
       - 배경: 흰색 또는 연한 회색
       - 테두리: 다크 그레이 또는 검정
       - 크기: 작은 정사각형 (예: 30x30px 또는 40x40px)
       - 텍스트 크기: 중간 크기
       - 모서리: 약간 둥글게 (선택적)
     - 위치: 좌측 또는 중앙 좌측
   
   - **감소 버튼 (-)**:
     - 텍스트: "-" 또는 "－"
     - 스타일: 증가 버튼과 동일
     - 위치: 증가 버튼 오른쪽
   
   - **버튼 간격**: 두 버튼 사이에 적절한 간격 (8-16px)

#### 5.5.5 재고 카드 스타일
- 배경: 흰색
- 테두리: 연한 회색 (1px)
- 모서리: 약간 둥글게 처리 (선택적)
- 그림자: 미세한 그림자 효과 (선택적)
- 패딩: 카드 내부에 적절한 여백 (16-20px)
- 정렬: 카드 내 요소들은 중앙 정렬

#### 5.5.6 기능 요구사항

- **재고 데이터 로드**
  - 백엔드 API를 통해 모든 메뉴의 재고 정보 조회
  - API 엔드포인트: `/api/menus/stock` 또는 `/api/admin/inventory`
  - 화면 로드 시 자동으로 재고 데이터 조회
  - 로딩 중 스켈레톤 UI 또는 로딩 스피너 표시 (선택적)

- **증가 버튼 (+) 동작**
  - 클릭 시:
    1. 해당 메뉴의 재고 수량을 1 증가시킴
    2. 즉시 UI에 반영 (낙관적 업데이트)
    3. 백엔드 API로 재고 업데이트 요청 (PUT/PATCH)
  - API 요청:
    - 엔드포인트: `/api/menus/{menuId}/stock`
    - 메서드: PUT 또는 PATCH
    - 본문: `{ stock: 현재수량 + 1 }` 또는 `{ increment: 1 }`
  - 성공 시: UI 상태 유지
  - 실패 시:
    - 원래 수량으로 롤백
    - 에러 메시지 표시: "재고 업데이트에 실패했습니다"

- **감소 버튼 (-) 동작**
  - 클릭 시:
    1. 해당 메뉴의 재고 수량을 1 감소시킴
    2. 즉시 UI에 반영 (낙관적 업데이트)
    3. 백엔드 API로 재고 업데이트 요청 (PUT/PATCH)
  - 재고가 0일 때 클릭 시:
    - 옵션 1: 아무 동작 하지 않음
    - 옵션 2: 0 이하로 내려가지 않도록 막고 메시지 표시
    - 옵션 3: 음수 허용 (비즈니스 로직에 따라)
  - API 요청: 증가 버튼과 동일한 패턴
  - 성공 시: UI 상태 유지
  - 실패 시: 원래 수량으로 롤백 및 에러 메시지

- **버튼 피드백**
  - 클릭 시: 버튼 크기 약간 축소 또는 배경색 변경
  - API 요청 중: 버튼 비활성화 (중복 클릭 방지)
  - 호버 시: 배경색 약간 어둡게

- **재고 부족 경고** (선택적)
  - 재고가 특정 수량 이하일 때 시각적 표시
  - 재고 0개: 빨간색 텍스트 또는 배경
  - 재고 3개 이하: 주황색 또는 노란색 경고 표시

### 5.6 주문 관리 섹션

관리자 화면의 주문 관리는 **접수된 주문**과 **제조중인 주문**을 분리하여 표시합니다. 이를 통해 주문의 진행 상태를 명확하게 파악하고 관리할 수 있습니다.

#### 5.6.1 접수된 주문 섹션

##### 레이아웃
- 위치: 재고 현황 섹션 아래
- 배경: 연한 회색 또는 흰색 박스
- 테두리: 연한 회색
- 모서리: 약간 둥글게 처리 (선택적)
- 패딩: 내부에 적절한 여백

##### 섹션 제목
- 텍스트: "접수된 주문"
- 위치: 섹션 최상단 좌측
- 스타일: 중간~큰 크기, 굵게 표시
- 색상: 다크 그레이 또는 검정

##### 주문 목록 레이아웃
- 주문 항목들을 세로로 나열 (리스트 형태)
- 각 항목은 한 줄 또는 여러 줄로 구성
- 항목 사이에 구분선 또는 간격 (선택적)
- 최신 주문이 위에 오도록 정렬 (시간 역순)
- 표시 대상: `pending` 또는 `received` 상태의 주문만 표시

##### 주문 항목 구성 요소
각 주문 항목은 다음 정보를 가로로 배치하여 표시합니다:

1. **주문 일시**
   - 위치: 항목 좌측
   - 형식: "{월}월 {일}일 {시}:{분}"
   - 예시: "7월 31일 13:00", "11월 12일 14:30"
   - 스타일:
     - 크기: 보통 크기
     - 색상: 다크 그레이
   - 시간 형식: 24시간 형식 ("13:00")

2. **주문 아이템**
   - 위치: 주문 일시 오른쪽
   - 형식: "{메뉴명} x {수량}"
   - 예시: "아메리카노(ICE) x 1", "카페라떼 x 2"
   - 스타일:
     - 크기: 보통 크기
     - 색상: 다크 그레이 또는 검정
   - 여러 아이템: 쉼표로 구분하여 모두 표시

3. **주문 금액**
   - 위치: 주문 아이템 오른쪽
   - 형식: "{금액}원"
   - 예시: "4,000원", "12,500원"
   - 스타일:
     - 크기: 보통 크기
     - 색상: 다크 그레이 또는 검정
     - 천 단위 구분 쉼표 표시

4. **제조 시작 버튼**
   - 위치: 항목 우측 끝
   - 텍스트: "제조 시작" (received 상태) 또는 "주문 접수" (pending 상태)
   - 스타일:
     - 배경: 흰색
     - 테두리: 주황색 (`#ff6f00`, 2px)
     - 텍스트 색상: 주황색 (`#ff6f00`)
     - 크기: 작은~중간 크기의 직사각형 버튼
     - 패딩: 10px (상하), 24px (좌우)
     - 모서리: 약간 둥글게 처리 (6px)
   - 호버 효과:
     - 배경: 주황색 (`#ff6f00`)
     - 텍스트: 흰색
   - 클릭 시: 주문 상태를 `inProgress`로 변경하고 "제조중인 주문" 섹션으로 이동

##### 빈 상태 처리
- 접수된 주문이 없을 때: "접수된 주문이 없습니다" 메시지 표시
- 스타일: 중앙 정렬, 연한 회색 텍스트, 40px 상하 패딩

#### 5.6.2 제조중인 주문 섹션

##### 레이아웃
- 위치: 접수된 주문 섹션 바로 아래
- 배경: 노란색 계열 배경 (`#fff8e1`)
- 테두리: 주황색 (`#ffb74d`, 2px)
- 모서리: 약간 둥글게 처리 (12px)
- 패딩: 내부에 적절한 여백 (24px)
- 그림자: 부드러운 그림자 효과 (`0 2px 8px rgba(255, 183, 77, 0.2)`)

##### 섹션 제목
- 텍스트: "제조중인 주문"
- 위치: 섹션 최상단 좌측
- 스타일: 중간~큰 크기, 굵게 표시
- 색상: 다크 그레이 또는 검정

##### 주문 목록 레이아웃
- 주문 항목들을 세로로 나열
- 각 항목에 강조 스타일 적용
- 항목 사이에 간격 (12px)
- 최신 주문이 위에 오도록 정렬
- 표시 대상: `inProgress` 상태의 주문만 표시

##### 주문 항목 구성 요소
접수된 주문과 동일한 정보를 표시하되, 다음과 같은 차별화된 스타일 적용:

1. **항목 배경**
   - 기본 배경: 노란색 (`#fff8e1`)
   - 호버 배경: 더 진한 노란색 (`#fff3cd`)
   - 테두리: 주황색 (`#ffb74d`, 2px)
   - 그림자: `0 2px 8px rgba(255, 183, 77, 0.2)`

2. **제조 완료 버튼**
   - 텍스트: "제조 완료"
   - 스타일:
     - 배경: 흰색
     - 테두리: 초록색 (`#2e7d32`, 2px)
     - 텍스트 색상: 초록색 (`#2e7d32`)
     - 크기: 작은~중간 크기의 직사각형 버튼
     - 패딩: 10px (상하), 24px (좌우)
     - 모서리: 약간 둥글게 처리 (6px)
   - 호버 효과:
     - 배경: 초록색 (`#2e7d32`)
     - 텍스트: 흰색
   - 클릭 시: 주문 상태를 `completed`로 변경

##### 빈 상태 처리
- 제조중인 주문이 없을 때: "제조중인 주문이 없습니다" 메시지 표시
- 스타일: 중앙 정렬, 연한 회색 텍스트, 40px 상하 패딩

##### 주문 항목 레이아웃 예시

**접수된 주문:**
```
┌─────────────────────────────────────────────────────────────────┐
│ 접수된 주문                                                      │
├─────────────────────────────────────────────────────────────────┤
│ 7월 31일 13:00   아메리카노(ICE) x 1      4,000원  [제조 시작]  │
├─────────────────────────────────────────────────────────────────┤
│ 11월 12일 14:30  카페라떼 x 2             10,000원 [제조 시작]  │
└─────────────────────────────────────────────────────────────────┘
```

**제조중인 주문 (노란색 배경):**
```
┌─────────────────────────────────────────────────────────────────┐
│ 제조중인 주문                                                    │
├─────────────────────────────────────────────────────────────────┤
│ 🟡 7월 31일 12:45  아메리카노(HOT) x 1   4,500원  [제조 완료]  │
├─────────────────────────────────────────────────────────────────┤
│ 🟡 11월 12일 14:00  카페라떼 x 1          5,000원  [제조 완료]  │
└─────────────────────────────────────────────────────────────────┘
```

#### 5.6.3 주문 상태 관리 및 워크플로우

주문은 다음과 같은 상태 흐름을 가집니다:

1. **주문 접수 전 (pending)**
   - 새로 생성된 주문의 기본 상태
   - "접수된 주문" 섹션에 표시
   - "주문 접수" 버튼 표시
   - 대시보드의 "총 주문"에만 포함

2. **주문 접수 (received)**
   - "주문 접수" 버튼 클릭 시 변경
   - "접수된 주문" 섹션에 표시
   - "제조 시작" 버튼 표시 (주황색)
   - 대시보드의 "총 주문", "주문 접수"에 포함

3. **제조 중 (inProgress)**
   - "제조 시작" 버튼 클릭 시 변경
   - **"제조중인 주문" 섹션으로 이동**
   - "제조 완료" 버튼 표시 (초록색)
   - 노란색 배경으로 시각적 강조
   - 대시보드의 "총 주문", "제조 중"에 포함

4. **제조 완료 (completed)**
   - "제조 완료" 버튼 클릭 시 변경
   - 목록에서 제거 또는 별도 섹션 표시
   - 대시보드의 "총 주문", "제조 완료"에 포함

**상태 전환 다이어그램:**
```
pending → received → inProgress → completed
  ↓         ↓            ↓
접수된    접수된      제조중인
주문      주문        주문
```

#### 5.6.4 기능 요구사항

##### 주문 목록 로드
- **접수된 주문**:
  - 백엔드 API를 통해 `pending` 또는 `received` 상태의 주문 조회
  - API 엔드포인트: `/api/orders?status=pending,received` 또는 `/api/admin/orders`
  - 화면 로드 시 자동으로 주문 목록 조회
  - 최신 주문이 위에 오도록 정렬 (createdAt 내림차순)

- **제조중인 주문**:
  - 백엔드 API를 통해 `inProgress` 상태의 주문 조회
  - API 엔드포인트: `/api/orders?status=inProgress`
  - 최신 주문이 위에 오도록 정렬

- **로딩 처리**:
  - 로딩 중 스켈레톤 UI 또는 로딩 스피너 표시 (선택적)

##### 빈 주문 목록 처리
- 접수된 주문이 없을 때: "접수된 주문이 없습니다" 메시지 표시
- 제조중인 주문이 없을 때: "제조중인 주문이 없습니다" 메시지 표시
- 스타일: 중앙 정렬, 연한 회색 텍스트

##### 제조 시작 버튼 동작
- 클릭 시:
  1. 해당 주문의 상태를 `inProgress`로 변경
  2. 주문을 "접수된 주문" 섹션에서 제거
  3. 주문을 "제조중인 주문" 섹션에 추가
  4. 즉시 UI에 반영
  5. 백엔드 API로 주문 상태 업데이트 요청 (PUT/PATCH)

- API 요청:
  - 엔드포인트: `/api/orders/{orderId}/status`
  - 메서드: PUT 또는 PATCH
  - 본문: `{ status: "inProgress" }`

- 성공 시:
  - 주문이 "제조중인 주문" 섹션으로 이동
  - 대시보드 통계 자동 갱신 (주문 접수 -1, 제조 중 +1)
  - 성공 피드백 표시 (선택적: 토스트 메시지)

- 실패 시:
  - 원래 상태로 롤백
  - 에러 메시지 표시: "상태 변경에 실패했습니다"

##### 제조 완료 버튼 동작
- 클릭 시:
  1. 해당 주문의 상태를 `completed`로 변경
  2. 주문을 "제조중인 주문" 섹션에서 제거
  3. 즉시 UI에 반영
  4. 백엔드 API로 주문 상태 업데이트 요청

- API 요청:
  - 엔드포인트: `/api/orders/{orderId}/status`
  - 메서드: PUT 또는 PATCH
  - 본문: `{ status: "completed" }`

- 성공 시:
  - 주문이 목록에서 사라짐
  - 대시보드 통계 자동 갱신 (제조 중 -1, 제조 완료 +1)

- 실패 시:
  - 원래 상태로 롤백
  - 에러 메시지 표시

##### 버튼 피드백
- **제조 시작 버튼**:
  - 클릭 시: 버튼 크기 약간 축소 (scale 0.98)
  - API 요청 중: 버튼 비활성화 + 로딩 스피너 (중복 클릭 방지)
  - 호버 시: 배경색 주황색으로 변경, 텍스트 흰색으로 변경
  - 활성 상태: transform scale(0.98)

- **제조 완료 버튼**:
  - 클릭 시: 버튼 크기 약간 축소
  - API 요청 중: 버튼 비활성화 + 로딩 스피너
  - 호버 시: 배경색 초록색으로 변경, 텍스트 흰색으로 변경

##### 통계 업데이트
- 주문 상태가 변경될 때마다 대시보드 통계 자동 갱신
- 실시간 또는 주기적 업데이트
- 숫자 변경 시 애니메이션 효과 (선택적)

- **주문 목록 자동 갱신** (선택적)
  - 주기적으로 새 주문 확인 (30초~1분마다)
  - 새 주문 알림 표시 (소리, 배지, 하이라이트 등)
  - WebSocket 또는 폴링 방식으로 실시간 업데이트

##### 주문 필터링/정렬 (선택적)
- 상태별 자동 분리: "접수된 주문", "제조중인 주문"
- 날짜별 필터: 오늘, 어제, 이번 주 등
- 정렬: 최신순, 오래된순, 금액순

### 5.7 UI/UX 요구사항

#### 5.7.1 디자인 시스템
- **전체 배경**: 흰색 또는 매우 연한 회색 (#F5F5F5)
- **텍스트 색상**:
  - 주요 텍스트: 다크 그레이 (#333333) 또는 검정
  - 보조 텍스트: 연한 회색 (#757575)
- **강조 색상**: 
  - 로고 영역: 다크 그레이
  - 활성화 버튼: 테두리 강조
- **섹션 스타일**:
  - 배경: 흰색 또는 연한 회색 박스
  - 테두리: 연한 회색 (#DDDDDD 또는 #E0E0E0)
  - 모서리: 약간 둥글게 (border-radius: 4-8px)
  - 그림자: 미세한 그림자 (선택적)
  - **제조중인 주문 섹션**: 
    - 배경: 노란색 (`#fff8e1`)
    - 테두리: 주황색 (`#ffb74d`, 2px)
    - 그림자: `0 2px 8px rgba(255, 183, 77, 0.2)`
- **버튼 스타일**:
  - 기본 배경: 흰색
  - 테두리: 상황별 색상 (2px)
  - 텍스트: 테두리와 동일한 색상
  - 호버: 배경색을 테두리 색상으로 변경, 텍스트 흰색으로 변경
  - 비활성화: 연한 회색, 투명도 적용
  - **제조 시작 버튼**: 주황색 (`#ff6f00`)
  - **제조 완료 버튼**: 초록색 (`#2e7d32`)

#### 5.7.2 타이포그래피
- **폰트**: 시스템 기본 폰트 또는 한글 가독성 좋은 폰트 (나눔고딕, 맑은고딕 등)
- **크기**:
  - 헤더 로고: 18-24px, 굵게
  - 섹션 제목: 18-20px, 굵게
  - 통계 텍스트: 14-16px, 보통
  - 메뉴명: 14-16px, 굵게
  - 재고 수량: 16-18px, 보통 또는 굵게
  - 주문 항목: 14-16px, 보통
  - 버튼 텍스트: 14-15px, 보통

#### 5.7.3 간격 및 여백
- 섹션 간 여백: 24-32px
- 카드 간 여백: 16-24px
- 카드 내부 패딩: 16-20px
- 섹션 내부 패딩: 20-24px
- 버튼 패딩: 8-12px (상하), 16-24px (좌우)
- 주문 항목 간 간격: 12-16px

#### 5.7.4 사용자 피드백

- **버튼 클릭 효과**:
  - 호버: 배경색 변경 (#F0F0F0) 또는 테두리 강조
  - 클릭: 버튼 크기 약간 축소 또는 배경색 더 어둡게
  - 활성 상태: 시각적으로 명확하게 구분

- **재고 조정 버튼**:
  - 클릭 시: 즉시 UI 업데이트 (낙관적 업데이트)
  - API 요청 중: 버튼 비활성화 (중복 클릭 방지)
  - 성공: 시각적 피드백 (선택적: 버튼 색상 변경, 체크 표시)
  - 실패: 원래 수량으로 롤백 + 에러 메시지

- **주문 접수 버튼**:
  - 클릭 시: 버튼 상태 즉시 변경
  - API 요청 중: 로딩 스피너 표시
  - 성공: 버튼 텍스트 변경 ("제조 시작"으로 변경)
  - 실패: 원래 상태로 롤백 + 에러 메시지

- **제조 시작 버튼**:
  - 클릭 시: 주문을 "제조중인 주문" 섹션으로 이동
  - API 요청 중: 버튼 비활성화 + 로딩 스피너
  - 성공: 주문 섹션 간 이동 애니메이션 (선택적)
  - 실패: 원래 섹션에 유지 + 에러 메시지

- **제조 완료 버튼**:
  - 클릭 시: 주문을 목록에서 제거
  - API 요청 중: 버튼 비활성화 + 로딩 스피너
  - 성공: 페이드 아웃 애니메이션으로 제거 (선택적)
  - 실패: 원래 상태 유지 + 에러 메시지

- **통계 업데이트**:
  - 실시간 또는 주기적 업데이트
  - 숫자 변경 시 애니메이션 효과 (선택적)

#### 5.7.5 로딩 상태

- **초기 로딩**:
  - 전체 화면 로딩 스피너 또는 스켈레톤 UI
  - 섹션별로 개별 로딩 상태 표시 가능

- **재고 데이터 로딩**:
  - 재고 카드 영역에 스켈레톤 UI
  - 또는 로딩 스피너

- **주문 목록 로딩**:
  - 주문 목록 영역에 스켈레톤 UI
  - 또는 로딩 스피너

- **API 요청 중**:
  - 해당 버튼만 비활성화 + 로딩 표시
  - 전체 화면은 계속 사용 가능

#### 5.7.6 에러 처리

- **API 에러**:
  - 통계 로드 실패: "통계를 불러올 수 없습니다" + 재시도 버튼
  - 재고 로드 실패: "재고 정보를 불러올 수 없습니다" + 재시도 버튼
  - 주문 로드 실패: "주문 목록을 불러올 수 없습니다" + 재시도 버튼
  - 재고 업데이트 실패: "재고 업데이트에 실패했습니다"
  - 주문 상태 변경 실패: "상태 변경에 실패했습니다"

- **에러 메시지 표시 방법**:
  - 토스트 메시지 (화면 상단 또는 하단, 3-5초 후 자동 사라짐)
  - 인라인 메시지 (해당 섹션 내)
  - 알림 모달 (중요한 에러)

- **에러 메시지 스타일**:
  - 배경: 연한 빨간색 (#FFEBEE)
  - 텍스트: 빨간색 (#D32F2F)
  - 아이콘: 경고 아이콘 (선택적)

#### 5.7.7 반응형 디자인

- **데스크톱 (1024px 이상)**:
  - 재고 카드: 3-4개씩 가로 배치
  - 주문 항목: 한 줄에 모든 정보 표시

- **태블릿 (768px - 1023px)**:
  - 재고 카드: 2-3개씩 가로 배치
  - 주문 항목: 한 줄 또는 두 줄로 표시

- **모바일 (767px 이하)**:
  - 재고 카드: 1-2개씩 가로 배치
  - 주문 항목: 여러 줄로 표시 (정보를 세로로 배치)
  - 헤더 버튼 크기 조정

#### 5.7.8 접근성 (선택적)
- 키보드 네비게이션 지원
- 포커스 표시: 파란색 테두리
- 버튼에 명확한 레이블
- 적절한 색상 대비 (WCAG AA 이상)
- 스크린 리더 지원 (aria-label)

### 5.8 데이터 구조

#### 5.8.1 재고 데이터 (백엔드 응답)
```javascript
{
  menuId: number,          // 메뉴 고유 ID
  menuName: string,        // 메뉴명 (예: "아메리카노 (ICE)")
  stock: number            // 현재 재고 수량 (예: 10)
}
```

**예시**:
```json
[
  {
    "menuId": 1,
    "menuName": "아메리카노 (ICE)",
    "stock": 10
  },
  {
    "menuId": 2,
    "menuName": "아메리카노 (HOT)",
    "stock": 10
  },
  {
    "menuId": 3,
    "menuName": "카페라떼",
    "stock": 10
  }
]
```

#### 5.8.2 주문 상태 통계 데이터 (백엔드 응답)
```javascript
{
  total: number,           // 총 주문 수
  pending: number,         // 주문 접수 전 수 (선택적)
  received: number,        // 주문 접수 수
  inProgress: number,      // 제조 중 수
  completed: number        // 제조 완료 수
}
```

**예시**:
```json
{
  "total": 1,
  "pending": 0,
  "received": 1,
  "inProgress": 0,
  "completed": 0
}
```

#### 5.8.3 주문 목록 데이터 (백엔드 응답)
```javascript
[
  {
    orderId: number,       // 주문 고유 ID
    createdAt: string,     // 주문 생성 일시 (ISO 8601 형식)
    items: [               // 주문 아이템 배열
      {
        menuId: number,    // 메뉴 ID
        menuName: string,  // 메뉴명
        quantity: number,  // 수량
        selectedOptions: [ // 선택된 옵션 (선택적)
          {
            optionId: number,
            optionName: string,
            optionPrice: number
          }
        ],
        itemPrice: number  // 아이템 가격
      }
    ],
    totalAmount: number,   // 주문 총 금액
    status: string         // 주문 상태: "pending" | "received" | "inProgress" | "completed"
  }
]
```

**예시**:
```json
[
  {
    "orderId": 123,
    "createdAt": "2025-07-31T13:00:00Z",
    "items": [
      {
        "menuId": 1,
        "menuName": "아메리카노(ICE)",
        "quantity": 1,
        "selectedOptions": [],
        "itemPrice": 4000
      }
    ],
    "totalAmount": 4000,
    "status": "received"
  },
  {
    "orderId": 124,
    "createdAt": "2025-11-12T14:30:00Z",
    "items": [
      {
        "menuId": 3,
        "menuName": "카페라떼",
        "quantity": 2,
        "selectedOptions": [
          {
            "optionId": 1,
            "optionName": "샷 추가",
            "optionPrice": 500
          }
        ],
        "itemPrice": 5500
      }
    ],
    "totalAmount": 11000,
    "status": "pending"
  }
]
```

#### 5.8.4 재고 업데이트 요청 데이터
```javascript
{
  menuId: number,          // 메뉴 ID
  stock: number            // 새로운 재고 수량
}
```

**또는 증분 방식**:
```javascript
{
  menuId: number,          // 메뉴 ID
  increment: number        // 증감량 (+1 또는 -1)
}
```

**예시**:
```json
{
  "menuId": 1,
  "stock": 11
}
```

#### 5.8.5 재고 업데이트 응답 데이터
```javascript
{
  success: boolean,        // 성공 여부
  menuId: number,          // 메뉴 ID
  stock: number,           // 업데이트된 재고 수량
  message: string          // 메시지 (선택적)
}
```

**예시**:
```json
{
  "success": true,
  "menuId": 1,
  "stock": 11,
  "message": "재고가 업데이트되었습니다"
}
```

#### 5.8.6 주문 상태 업데이트 요청 데이터
```javascript
{
  orderId: number,         // 주문 ID
  status: string           // 새로운 상태: "received" | "inProgress" | "completed"
}
```

**예시**:
```json
{
  "orderId": 123,
  "status": "received"
}
```

#### 5.8.7 주문 상태 업데이트 응답 데이터
```javascript
{
  success: boolean,        // 성공 여부
  orderId: number,         // 주문 ID
  status: string,          // 업데이트된 상태
  message: string          // 메시지 (선택적)
}
```

**예시**:
```json
{
  "success": true,
  "orderId": 123,
  "status": "received",
  "message": "주문이 접수되었습니다"
}
```

### 5.9 API 엔드포인트

#### 5.9.1 관리자 대시보드 통계 조회
- **Method**: GET
- **Endpoint**: `/api/orders/statistics` 또는 `/api/admin/dashboard`
- **설명**: 주문 상태별 집계 통계를 조회
- **요청 파라미터**: 없음
- **응답**:
  ```javascript
  {
    success: boolean,
    data: {
      total: number,
      pending: number,
      received: number,
      inProgress: number,
      completed: number
    }
  }
  ```

#### 5.9.2 재고 목록 조회
- **Method**: GET
- **Endpoint**: `/api/menus/stock` 또는 `/api/admin/inventory`
- **설명**: 모든 메뉴의 재고 정보를 조회
- **요청 파라미터**: 없음
- **응답**:
  ```javascript
  {
    success: boolean,
    data: [
      {
        menuId: number,
        menuName: string,
        stock: number
      }
    ]
  }
  ```

#### 5.9.3 재고 업데이트
- **Method**: PUT 또는 PATCH
- **Endpoint**: `/api/menus/{menuId}/stock`
- **설명**: 특정 메뉴의 재고를 업데이트
- **요청 본문**:
  ```javascript
  {
    stock: number  // 새로운 재고 수량
  }
  ```
  또는 증분 방식:
  ```javascript
  {
    increment: number  // +1 또는 -1
  }
  ```
- **응답**:
  ```javascript
  {
    success: boolean,
    menuId: number,
    stock: number,
    message: string
  }
  ```

#### 5.9.4 주문 목록 조회
- **Method**: GET
- **Endpoint**: `/api/orders` 또는 `/api/admin/orders`
- **설명**: 모든 주문 목록을 조회 (관리자용)
- **요청 파라미터** (선택적):
  - `status`: 주문 상태 필터 (pending, received, inProgress, completed)
  - `limit`: 조회할 주문 수
  - `offset`: 페이징 오프셋
- **응답**:
  ```javascript
  {
    success: boolean,
    data: [
      {
        orderId: number,
        createdAt: string,
        items: array,
        totalAmount: number,
        status: string
      }
    ]
  }
  ```

#### 5.9.5 주문 상태 업데이트
- **Method**: PUT 또는 PATCH
- **Endpoint**: `/api/orders/{orderId}/status`
- **설명**: 특정 주문의 상태를 변경
- **요청 본문**:
  ```javascript
  {
    status: string  // "received" | "inProgress" | "completed"
  }
  ```
- **응답**:
  ```javascript
  {
    success: boolean,
    orderId: number,
    status: string,
    message: string
  }
  ```

### 5.10 구현 우선순위

#### 5.10.1 필수 기능 (MVP)
1. 헤더 네비게이션 (로고, 화면 전환 버튼)
2. 관리자 대시보드 (주문 통계 표시)
3. 재고 현황 카드 표시
4. 재고 증가/감소 버튼 (API 연동)
5. 주문 목록 표시
6. 주문 접수 버튼 (상태 변경)
7. 통계 자동 갱신
8. 기본 에러 처리

#### 5.10.2 권장 기능
1. 로딩 상태 표시 (스켈레톤 UI 또는 스피너)
2. 버튼 클릭 피드백 (호버, 클릭 효과)
3. 재고 부족 경고 표시
4. 주문 상태별 버튼 변경
5. 반응형 디자인
6. 토스트 메시지 (성공/실패)

#### 5.10.3 선택적 기능
1. 주문 실시간 업데이트 (WebSocket 또는 폴링)
2. 새 주문 알림 (소리, 배지)
3. 주문 필터링 및 정렬
4. 주문 상세 모달
5. 통계 차트 또는 그래프
6. 재고 이력 관리
7. 주문 다중 상태 관리 (제조 중, 제조 완료)
8. 접근성 (키보드 네비게이션)

### 5.11 개발 가이드라인

#### 5.11.1 컴포넌트 구조 (React 기준)
```
AdminPage/
├── Header
│   ├── Logo
│   └── Navigation
├── DashboardSection
│   ├── SectionTitle
│   └── OrderStatistics
├── InventorySection
│   ├── SectionTitle
│   └── InventoryCard (반복)
│       ├── MenuName
│       ├── StockCount
│       └── StockButtons
│           ├── IncrementButton
│           └── DecrementButton
└── OrdersSection
    ├── SectionTitle
    └── OrderList
        └── OrderItem (반복)
            ├── OrderDate
            ├── OrderItems
            ├── OrderAmount
            └── OrderActionButton
```

#### 5.11.2 상태 관리
- **통계 데이터**: 주문 상태별 집계 (useState 또는 전역 상태)
- **재고 데이터**: 메뉴별 재고 목록 (useState 또는 전역 상태)
- **주문 목록**: 전체 주문 배열 (useState 또는 전역 상태)
- **로딩 상태**: 각 섹션별 로딩 여부 (useState)
- **에러 상태**: 에러 메시지 (useState)

#### 5.11.3 주요 함수
- `fetchStatistics()`: 주문 통계 조회
- `fetchInventory()`: 재고 목록 조회
- `updateStock(menuId, newStock)`: 재고 업데이트
- `incrementStock(menuId)`: 재고 증가
- `decrementStock(menuId)`: 재고 감소
- `fetchOrders()`: 주문 목록 조회
- `updateOrderStatus(orderId, status)`: 주문 상태 변경
- `refreshDashboard()`: 통계 및 주문 목록 갱신

#### 5.11.4 주의사항
- 재고 변경 시 낙관적 업데이트 후 API 호출
- API 실패 시 롤백 처리 필수
- 주문 상태 변경 시 통계 자동 갱신
- 재고가 0 이하로 내려가지 않도록 검증 (비즈니스 로직에 따라)
- 날짜/시간 형식 일관성 유지
- 여러 아이템이 있는 주문의 표시 방법 결정

#### 5.11.5 데이터 흐름
1. **초기 로드**:
   - 통계, 재고, 주문 목록 병렬 조회
   - 각 섹션별 로딩 상태 관리

2. **재고 업데이트**:
   - 사용자가 +/- 버튼 클릭
   - UI 즉시 업데이트 (낙관적)
   - API 요청
   - 성공: UI 유지
   - 실패: 롤백 + 에러 표시

3. **주문 상태 변경**:
   - 사용자가 주문 접수 버튼 클릭
   - 버튼 상태 즉시 변경
   - API 요청
   - 성공: 통계 갱신
   - 실패: 원래 상태로 롤백 + 에러 표시

---

## 6. 공통 요구사항

### 6.1 라우팅
- 주문하기 화면: `/` 또는 `/order`
- 관리자 화면: `/admin`
- React Router 또는 Next.js Router 사용

### 6.2 에러 처리
- 모든 API 호출에 try-catch 또는 .catch() 적용
- 사용자에게 친화적인 에러 메시지 표시
- 네트워크 에러, 서버 에러, 데이터 검증 에러 구분

### 6.3 코드 구조
- 컴포넌트는 재사용 가능하게 설계
- API 호출 로직은 별도 파일로 분리 (services/ 또는 api/)
- 상수는 별도 파일로 관리 (constants.js)
- 유틸리티 함수는 utils/ 폴더에 분리

### 6.4 스타일링
- CSS Modules, Styled Components, 또는 Tailwind CSS 사용 가능
- 일관된 디자인 시스템 유지
- 색상, 폰트, 간격 등을 변수로 관리

### 6.5 성능 최적화 (선택적)
- 이미지 지연 로딩
- API 응답 캐싱
- 불필요한 리렌더링 방지 (React.memo, useMemo, useCallback)
- 디바운싱/스로틀링 (연속 클릭 방지)

---

## 7. 프로젝트 일정 (예시)

### 7.1 Phase 1 - 기본 구현 (1-2주)
- 주문하기 화면 기본 UI
- 관리자 화면 기본 UI
- 백엔드 API 연동
- 필수 기능 구현

### 7.2 Phase 2 - 기능 개선 (1주)
- 에러 처리 강화
- 로딩 상태 추가
- 반응형 디자인 적용
- 사용자 피드백 개선

### 7.3 Phase 3 - 최적화 및 테스트 (선택적)
- 성능 최적화
- 접근성 개선
- 버그 수정
- 사용자 테스트

---

## 8. 백엔드 개발 상세 요구사항

### 8.1 백엔드 개요

백엔드는 Node.js와 Express 프레임워크를 사용하여 구축되며, PostgreSQL 데이터베이스를 통해 메뉴, 옵션, 주문 데이터를 관리합니다. RESTful API를 제공하여 프론트엔드와 통신합니다.

#### 8.1.1 기술 스택
- **런타임**: Node.js (v18 이상 권장)
- **프레임워크**: Express.js
- **데이터베이스**: PostgreSQL (v14 이상 권장)
- **데이터베이스 클라이언트**: pg (node-postgres)
- **환경 변수 관리**: dotenv
- **CORS**: cors 미들웨어

#### 8.1.2 프로젝트 구조
```
server/
├── src/
│   ├── config/
│   │   └── database.js          # DB 연결 설정
│   ├── models/
│   │   ├── menu.js              # Menu 모델
│   │   ├── option.js            # Option 모델
│   │   └── order.js             # Order 모델
│   ├── routes/
│   │   ├── menus.js             # 메뉴 관련 라우트
│   │   ├── orders.js            # 주문 관련 라우트
│   │   └── admin.js             # 관리자 관련 라우트
│   ├── controllers/
│   │   ├── menuController.js    # 메뉴 비즈니스 로직
│   │   ├── orderController.js   # 주문 비즈니스 로직
│   │   └── adminController.js   # 관리자 비즈니스 로직
│   ├── middleware/
│   │   ├── errorHandler.js      # 에러 처리 미들웨어
│   │   └── validator.js         # 요청 검증 미들웨어
│   └── app.js                   # Express 앱 설정
├── .env                         # 환경 변수
├── package.json
└── server.js                    # 서버 시작점
```

### 8.2 데이터베이스 설계

#### 8.2.1 ERD (Entity Relationship Diagram)
```
┌─────────────────┐
│     Menus       │
├─────────────────┤
│ menu_id (PK)    │
│ name            │
│ description     │
│ price           │
│ image_url       │
│ stock           │
│ created_at      │
│ updated_at      │
└─────────────────┘
         │
         │ 1
         │
         │ N
         ↓
┌─────────────────┐
│    Options      │
├─────────────────┤
│ option_id (PK)  │
│ menu_id (FK)    │
│ name            │
│ price           │
│ created_at      │
└─────────────────┘

┌─────────────────┐
│     Orders      │
├─────────────────┤
│ order_id (PK)   │
│ total_amount    │
│ status          │
│ created_at      │
│ updated_at      │
└─────────────────┘
         │
         │ 1
         │
         │ N
         ↓
┌─────────────────┐
│  Order_Items    │
├─────────────────┤
│ item_id (PK)    │
│ order_id (FK)   │
│ menu_id (FK)    │
│ quantity        │
│ price           │
│ created_at      │
└─────────────────┘
         │
         │ 1
         │
         │ N
         ↓
┌──────────────────────┐
│ Order_Item_Options   │
├──────────────────────┤
│ id (PK)              │
│ item_id (FK)         │
│ option_id (FK)       │
│ option_name          │
│ option_price         │
└──────────────────────┘
```

#### 8.2.2 테이블 상세 스키마

##### Menus 테이블
커피 메뉴의 기본 정보를 저장합니다.

```sql
CREATE TABLE menus (
  menu_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  price INTEGER NOT NULL CHECK (price >= 0),
  image_url VARCHAR(500),
  stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스 추가
CREATE INDEX idx_menus_stock ON menus(stock);
```

**컬럼 설명:**
- `menu_id`: 메뉴 고유 ID (자동 증가)
- `name`: 메뉴명 (예: "아메리카노 (ICE)", "카페라떼")
- `description`: 메뉴 설명 (예: "시원한 아이스 아메리카노")
- `price`: 기본 가격 (정수, 원 단위)
- `image_url`: 메뉴 이미지 URL
- `stock`: 현재 재고 수량
- `created_at`: 생성 일시
- `updated_at`: 수정 일시

**샘플 데이터:**
```sql
INSERT INTO menus (name, description, price, image_url, stock) VALUES
('아메리카노 (ICE)', '깔끔하고 시원한 아이스 아메리카노', 4000, 'https://images.unsplash.com/photo-1461023058943-07fcbe16d735', 10),
('아메리카노 (HOT)', '따뜻하고 진한 핫 아메리카노', 4000, 'https://images.unsplash.com/photo-1514432324607-a09d9b4aefdd', 10),
('카페라떼', '부드러운 우유와 에스프레소의 조화', 5000, 'https://images.unsplash.com/photo-1561882468-9110e03e0f78', 10);
```

##### Options 테이블
메뉴에 추가할 수 있는 옵션을 저장합니다.

```sql
CREATE TABLE options (
  option_id SERIAL PRIMARY KEY,
  menu_id INTEGER NOT NULL REFERENCES menus(menu_id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  price INTEGER NOT NULL DEFAULT 0 CHECK (price >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스 추가
CREATE INDEX idx_options_menu_id ON options(menu_id);
```

**컬럼 설명:**
- `option_id`: 옵션 고유 ID (자동 증가)
- `menu_id`: 연결된 메뉴 ID (외래키)
- `name`: 옵션명 (예: "샷 추가", "시럽 추가")
- `price`: 옵션 추가 가격 (0일 수 있음)
- `created_at`: 생성 일시

**샘플 데이터:**
```sql
-- 아메리카노 (ICE) 옵션
INSERT INTO options (menu_id, name, price) VALUES
(1, '샷 추가', 500),
(1, '시럽 추가', 500);

-- 아메리카노 (HOT) 옵션
INSERT INTO options (menu_id, name, price) VALUES
(2, '샷 추가', 500),
(2, '시럽 추가', 500);

-- 카페라떼 옵션
INSERT INTO options (menu_id, name, price) VALUES
(3, '샷 추가', 500),
(3, '바닐라 시럽', 500),
(3, '헤이즐넛 시럽', 500);
```

##### Orders 테이블
주문의 기본 정보를 저장합니다.

```sql
CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  total_amount INTEGER NOT NULL CHECK (total_amount >= 0),
  status VARCHAR(20) NOT NULL DEFAULT 'pending' 
    CHECK (status IN ('pending', 'received', 'inProgress', 'completed')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스 추가
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
```

**컬럼 설명:**
- `order_id`: 주문 고유 ID (자동 증가)
- `total_amount`: 주문 총 금액
- `status`: 주문 상태
  - `pending`: 주문 접수 전
  - `received`: 주문 접수됨
  - `inProgress`: 제조 중
  - `completed`: 제조 완료
- `created_at`: 주문 일시
- `updated_at`: 상태 변경 일시

##### Order_Items 테이블
주문에 포함된 메뉴 아이템을 저장합니다.

```sql
CREATE TABLE order_items (
  item_id SERIAL PRIMARY KEY,
  order_id INTEGER NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
  menu_id INTEGER NOT NULL REFERENCES menus(menu_id),
  quantity INTEGER NOT NULL CHECK (quantity > 0),
  price INTEGER NOT NULL CHECK (price >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스 추가
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_menu_id ON order_items(menu_id);
```

**컬럼 설명:**
- `item_id`: 아이템 고유 ID (자동 증가)
- `order_id`: 연결된 주문 ID (외래키)
- `menu_id`: 연결된 메뉴 ID (외래키)
- `quantity`: 주문 수량
- `price`: 주문 당시 메뉴 가격 (스냅샷)
- `created_at`: 생성 일시

##### Order_Item_Options 테이블
주문 아이템에 선택된 옵션을 저장합니다.

```sql
CREATE TABLE order_item_options (
  id SERIAL PRIMARY KEY,
  item_id INTEGER NOT NULL REFERENCES order_items(item_id) ON DELETE CASCADE,
  option_id INTEGER NOT NULL REFERENCES options(option_id),
  option_name VARCHAR(50) NOT NULL,
  option_price INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스 추가
CREATE INDEX idx_order_item_options_item_id ON order_item_options(item_id);
```

**컬럼 설명:**
- `id`: 고유 ID (자동 증가)
- `item_id`: 연결된 주문 아이템 ID (외래키)
- `option_id`: 연결된 옵션 ID (외래키)
- `option_name`: 옵션명 스냅샷 (주문 당시 이름)
- `option_price`: 옵션 가격 스냅샷 (주문 당시 가격)
- `created_at`: 생성 일시

**스냅샷 저장 이유:** 주문 후 메뉴 가격이나 옵션이 변경되어도 주문 당시의 정보를 유지하기 위함

### 8.3 사용자 흐름 및 데이터 플로우

#### 8.3.1 메뉴 조회 플로우
```
1. 사용자가 주문하기 화면 접속
   ↓
2. 프론트엔드가 GET /api/menus 호출
   ↓
3. 백엔드가 Menus 테이블에서 모든 메뉴 조회
   ↓
4. 각 메뉴의 Options도 함께 조회 (JOIN)
   ↓
5. JSON 형태로 응답
   ↓
6. 프론트엔드가 메뉴 카드로 렌더링
   (재고 수량은 표시하지 않음)
```

#### 8.3.2 장바구니 담기 플로우 (프론트엔드만)
```
1. 사용자가 메뉴 선택 + 옵션 선택
   ↓
2. "담기" 버튼 클릭
   ↓
3. 선택한 메뉴와 옵션을 프론트엔드 상태(state)에 저장
   ↓
4. 장바구니 UI 업데이트
   (이 단계에서는 서버 통신 없음)
```

#### 8.3.3 주문하기 플로우
```
1. 사용자가 장바구니에서 "주문하기" 버튼 클릭
   ↓
2. 프론트엔드가 POST /api/orders 호출
   본문: {
     items: [
       {
         menuId: 1,
         quantity: 2,
         options: [{ optionId: 1 }, { optionId: 2 }]
       }
     ]
   }
   ↓
3. 백엔드가 요청 검증
   - 메뉴 ID 존재 여부
   - 옵션 ID 유효성
   - 재고 충분 여부
   ↓
4. 트랜잭션 시작
   ↓
5. Orders 테이블에 주문 생성
   - status: 'received'
   - total_amount: 계산된 총 금액
   ↓
6. Order_Items 테이블에 아이템 추가
   ↓
7. Order_Item_Options 테이블에 옵션 추가
   ↓
8. Menus 테이블에서 재고 차감
   UPDATE menus SET stock = stock - quantity
   ↓
9. 트랜잭션 커밋
   ↓
10. 생성된 주문 정보 응답
    ↓
11. 프론트엔드가 주문 완료 메시지 표시
    장바구니 비우기
```

#### 8.3.4 관리자 주문 조회 플로우
```
1. 관리자가 관리자 화면 접속
   ↓
2. 프론트엔드가 GET /api/admin/orders 호출
   ↓
3. 백엔드가 Orders를 조회하고
   관련 Order_Items, Order_Item_Options를 JOIN
   ↓
4. 상태별로 그룹화된 주문 목록 응답
   ↓
5. 프론트엔드가 "접수된 주문", "제조중인 주문"으로 분리 표시
```

#### 8.3.5 주문 상태 변경 플로우
```
1. 관리자가 "제조 시작" 또는 "제조 완료" 버튼 클릭
   ↓
2. 프론트엔드가 PATCH /api/orders/:orderId/status 호출
   본문: { status: 'inProgress' } 또는 { status: 'completed' }
   ↓
3. 백엔드가 주문 상태 검증
   - 유효한 상태 전환인지 확인
   - pending → received → inProgress → completed
   ↓
4. Orders 테이블 업데이트
   UPDATE orders SET status = ?, updated_at = NOW()
   ↓
5. 업데이트된 주문 정보 응답
   ↓
6. 프론트엔드가 UI 업데이트
   - 주문을 해당 섹션으로 이동
   - 대시보드 통계 갱신
```

#### 8.3.6 재고 조회 플로우 (관리자)
```
1. 관리자가 관리자 화면 접속
   ↓
2. 프론트엔드가 GET /api/admin/inventory 호출
   ↓
3. 백엔드가 Menus 테이블에서 menu_id, name, stock 조회
   ↓
4. 재고 목록 응답
   ↓
5. 프론트엔드가 재고 현황 카드로 렌더링
```

#### 8.3.7 재고 수정 플로우
```
1. 관리자가 +/- 버튼 클릭
   ↓
2. 프론트엔드가 낙관적 업데이트 (UI 즉시 반영)
   ↓
3. PATCH /api/admin/inventory/:menuId 호출
   본문: { stock: 11 } (새로운 재고 수량)
   ↓
4. 백엔드가 Menus 테이블 업데이트
   UPDATE menus SET stock = ?, updated_at = NOW()
   ↓
5. 성공 시: 응답 200 OK
   실패 시: 프론트엔드가 롤백
```

### 8.4 API 설계

#### 8.4.1 API 엔드포인트 목록

##### 메뉴 관련 API
| 메서드 | 엔드포인트 | 설명 | 권한 |
|--------|-----------|------|------|
| GET | `/api/menus` | 전체 메뉴 목록 조회 (옵션 포함) | Public |
| GET | `/api/menus/:menuId` | 특정 메뉴 상세 조회 | Public |

##### 주문 관련 API
| 메서드 | 엔드포인트 | 설명 | 권한 |
|--------|-----------|------|------|
| POST | `/api/orders` | 새 주문 생성 | Public |
| GET | `/api/orders/:orderId` | 특정 주문 상세 조회 | Public |

##### 관리자 관련 API
| 메서드 | 엔드포인트 | 설명 | 권한 |
|--------|-----------|------|------|
| GET | `/api/admin/statistics` | 주문 통계 조회 | Admin |
| GET | `/api/admin/inventory` | 재고 현황 조회 | Admin |
| PATCH | `/api/admin/inventory/:menuId` | 재고 수정 | Admin |
| GET | `/api/admin/orders` | 전체 주문 목록 조회 | Admin |
| PATCH | `/api/admin/orders/:orderId/status` | 주문 상태 변경 | Admin |

#### 8.4.2 API 상세 스펙

##### 1. GET /api/menus
전체 메뉴 목록과 각 메뉴의 옵션을 조회합니다.

**요청:**
```http
GET /api/menus HTTP/1.1
Host: localhost:5000
```

**응답 (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "menuId": 1,
      "name": "아메리카노 (ICE)",
      "description": "깔끔하고 시원한 아이스 아메리카노",
      "price": 4000,
      "imageUrl": "https://images.unsplash.com/photo-1461023058943-07fcbe16d735",
      "options": [
        {
          "optionId": 1,
          "name": "샷 추가",
          "price": 500
        },
        {
          "optionId": 2,
          "name": "시럽 추가",
          "price": 500
        }
      ]
    },
    {
      "menuId": 2,
      "name": "아메리카노 (HOT)",
      "description": "따뜻하고 진한 핫 아메리카노",
      "price": 4000,
      "imageUrl": "https://images.unsplash.com/photo-1514432324607-a09d9b4aefdd",
      "options": [
        {
          "optionId": 3,
          "name": "샷 추가",
          "price": 500
        },
        {
          "optionId": 4,
          "name": "시럽 추가",
          "price": 500
        }
      ]
    }
  ]
}
```

**에러 응답 (500):**
```json
{
  "success": false,
  "error": "메뉴 목록을 불러오는데 실패했습니다"
}
```

**비즈니스 로직:**
1. `menus` 테이블에서 모든 메뉴 조회
2. 각 메뉴의 `options`를 JOIN하여 함께 조회
3. 재고(stock)는 응답에 포함하지 않음 (고객용)
4. `created_at`, `updated_at`은 응답에 포함하지 않음

**SQL 쿼리:**
```sql
-- 메뉴 조회
SELECT menu_id, name, description, price, image_url
FROM menus
ORDER BY menu_id;

-- 각 메뉴의 옵션 조회
SELECT option_id, menu_id, name, price
FROM options
WHERE menu_id IN (1, 2, 3...)
ORDER BY option_id;
```

##### 2. GET /api/menus/:menuId
특정 메뉴의 상세 정보를 조회합니다.

**요청:**
```http
GET /api/menus/1 HTTP/1.1
Host: localhost:5000
```

**응답 (200 OK):**
```json
{
  "success": true,
  "data": {
    "menuId": 1,
    "name": "아메리카노 (ICE)",
    "description": "깔끔하고 시원한 아이스 아메리카노",
    "price": 4000,
    "imageUrl": "https://images.unsplash.com/photo-1461023058943-07fcbe16d735",
    "options": [
      {
        "optionId": 1,
        "name": "샷 추가",
        "price": 500
      },
      {
        "optionId": 2,
        "name": "시럽 추가",
        "price": 500
      }
    ]
  }
}
```

**에러 응답 (404):**
```json
{
  "success": false,
  "error": "메뉴를 찾을 수 없습니다"
}
```

**SQL 쿼리:**
```sql
-- 메뉴 조회
SELECT menu_id, name, description, price, image_url
FROM menus
WHERE menu_id = $1;

-- 옵션 조회
SELECT option_id, name, price
FROM options
WHERE menu_id = $1
ORDER BY option_id;
```

##### 3. POST /api/orders
새로운 주문을 생성하고 재고를 차감합니다.

**요청:**
```http
POST /api/orders HTTP/1.1
Host: localhost:5000
Content-Type: application/json

{
  "items": [
    {
      "menuId": 1,
      "quantity": 2,
      "options": [
        { "optionId": 1 },
        { "optionId": 2 }
      ]
    },
    {
      "menuId": 3,
      "quantity": 1,
      "options": []
    }
  ]
}
```

**요청 본문 검증:**
- `items`: 배열, 필수, 최소 1개 이상
- `items[].menuId`: 정수, 필수, 존재하는 메뉴 ID
- `items[].quantity`: 정수, 필수, 1 이상
- `items[].options`: 배열, 선택적
- `items[].options[].optionId`: 정수, 필수 (옵션 배열이 있을 경우)

**응답 (201 Created):**
```json
{
  "success": true,
  "data": {
    "orderId": 15,
    "totalAmount": 14000,
    "status": "received",
    "items": [
      {
        "menuName": "아메리카노 (ICE)",
        "quantity": 2,
        "price": 4000,
        "options": [
          { "name": "샷 추가", "price": 500 },
          { "name": "시럽 추가", "price": 500 }
        ],
        "subtotal": 10000
      },
      {
        "menuName": "카페라떼",
        "quantity": 1,
        "price": 5000,
        "options": [],
        "subtotal": 5000
      }
    ],
    "createdAt": "2025-11-12T14:30:00.000Z"
  }
}
```

**에러 응답:**

재고 부족 (400 Bad Request):
```json
{
  "success": false,
  "error": "재고가 부족합니다",
  "details": {
    "menuName": "아메리카노 (ICE)",
    "requested": 5,
    "available": 3
  }
}
```

유효하지 않은 메뉴 (404 Not Found):
```json
{
  "success": false,
  "error": "메뉴를 찾을 수 없습니다",
  "details": {
    "menuId": 999
  }
}
```

유효하지 않은 옵션 (404 Not Found):
```json
{
  "success": false,
  "error": "옵션을 찾을 수 없습니다",
  "details": {
    "optionId": 999,
    "menuId": 1
  }
}
```

**비즈니스 로직:**
1. 요청 검증
   - 모든 메뉴 ID가 존재하는지 확인
   - 모든 옵션 ID가 해당 메뉴에 속하는지 확인
   
2. 재고 확인
   - 각 메뉴의 현재 재고 조회
   - 주문 수량이 재고보다 많으면 에러 반환
   
3. 금액 계산
   - 각 아이템의 (메뉴 가격 + 옵션 가격들) × 수량
   - 총 금액 합산
   
4. 트랜잭션으로 처리
   - Orders 테이블에 주문 생성
   - Order_Items 테이블에 아이템 추가
   - Order_Item_Options 테이블에 옵션 추가
   - Menus 테이블에서 재고 차감
   
5. 생성된 주문 정보 반환

**SQL 쿼리 (트랜잭션):**
```sql
BEGIN;

-- 1. 재고 확인 (FOR UPDATE로 락 설정)
SELECT menu_id, name, stock
FROM menus
WHERE menu_id IN (1, 3)
FOR UPDATE;

-- 2. 주문 생성
INSERT INTO orders (total_amount, status)
VALUES (14000, 'received')
RETURNING order_id, created_at;

-- 3. 주문 아이템 추가
INSERT INTO order_items (order_id, menu_id, quantity, price)
VALUES 
  (15, 1, 2, 4000),
  (15, 3, 1, 5000)
RETURNING item_id;

-- 4. 주문 아이템 옵션 추가
INSERT INTO order_item_options (item_id, option_id, option_name, option_price)
VALUES 
  (101, 1, '샷 추가', 500),
  (101, 2, '시럽 추가', 500);

-- 5. 재고 차감
UPDATE menus
SET stock = stock - 2, updated_at = NOW()
WHERE menu_id = 1;

UPDATE menus
SET stock = stock - 1, updated_at = NOW()
WHERE menu_id = 3;

COMMIT;
```

##### 4. GET /api/orders/:orderId
특정 주문의 상세 정보를 조회합니다.

**요청:**
```http
GET /api/orders/15 HTTP/1.1
Host: localhost:5000
```

**응답 (200 OK):**
```json
{
  "success": true,
  "data": {
    "orderId": 15,
    "totalAmount": 14000,
    "status": "received",
    "items": [
      {
        "menuName": "아메리카노 (ICE)",
        "quantity": 2,
        "price": 4000,
        "options": [
          { "name": "샷 추가", "price": 500 },
          { "name": "시럽 추가", "price": 500 }
        ]
      },
      {
        "menuName": "카페라떼",
        "quantity": 1,
        "price": 5000,
        "options": []
      }
    ],
    "createdAt": "2025-11-12T14:30:00.000Z",
    "updatedAt": "2025-11-12T14:30:00.000Z"
  }
}
```

**에러 응답 (404):**
```json
{
  "success": false,
  "error": "주문을 찾을 수 없습니다"
}
```

**SQL 쿼리:**
```sql
-- 주문 조회
SELECT order_id, total_amount, status, created_at, updated_at
FROM orders
WHERE order_id = $1;

-- 주문 아이템 조회
SELECT 
  oi.item_id,
  oi.quantity,
  oi.price,
  m.name as menu_name
FROM order_items oi
JOIN menus m ON oi.menu_id = m.menu_id
WHERE oi.order_id = $1;

-- 각 아이템의 옵션 조회
SELECT 
  oio.item_id,
  oio.option_name,
  oio.option_price
FROM order_item_options oio
WHERE oio.item_id IN (101, 102...);
```

##### 5. GET /api/admin/statistics
주문 통계를 조회합니다.

**요청:**
```http
GET /api/admin/statistics HTTP/1.1
Host: localhost:5000
```

**응답 (200 OK):**
```json
{
  "success": true,
  "data": {
    "total": 15,
    "received": 3,
    "inProgress": 5,
    "completed": 7
  }
}
```

**SQL 쿼리:**
```sql
SELECT 
  COUNT(*) as total,
  COUNT(*) FILTER (WHERE status = 'received') as received,
  COUNT(*) FILTER (WHERE status = 'inProgress') as in_progress,
  COUNT(*) FILTER (WHERE status = 'completed') as completed
FROM orders;
```

##### 6. GET /api/admin/inventory
재고 현황을 조회합니다.

**요청:**
```http
GET /api/admin/inventory HTTP/1.1
Host: localhost:5000
```

**응답 (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "menuId": 1,
      "menuName": "아메리카노 (ICE)",
      "stock": 8
    },
    {
      "menuId": 2,
      "menuName": "아메리카노 (HOT)",
      "stock": 10
    },
    {
      "menuId": 3,
      "menuName": "카페라떼",
      "stock": 5
    }
  ]
}
```

**SQL 쿼리:**
```sql
SELECT menu_id, name as menu_name, stock
FROM menus
ORDER BY menu_id;
```

##### 7. PATCH /api/admin/inventory/:menuId
특정 메뉴의 재고를 수정합니다.

**요청:**
```http
PATCH /api/admin/inventory/1 HTTP/1.1
Host: localhost:5000
Content-Type: application/json

{
  "stock": 15
}
```

**요청 본문 검증:**
- `stock`: 정수, 필수, 0 이상

**응답 (200 OK):**
```json
{
  "success": true,
  "data": {
    "menuId": 1,
    "menuName": "아메리카노 (ICE)",
    "stock": 15
  }
}
```

**에러 응답 (404):**
```json
{
  "success": false,
  "error": "메뉴를 찾을 수 없습니다"
}
```

**에러 응답 (400):**
```json
{
  "success": false,
  "error": "재고는 0 이상이어야 합니다"
}
```

**SQL 쿼리:**
```sql
UPDATE menus
SET stock = $1, updated_at = NOW()
WHERE menu_id = $2
RETURNING menu_id, name as menu_name, stock;
```

##### 8. GET /api/admin/orders
전체 주문 목록을 조회합니다.

**요청:**
```http
GET /api/admin/orders HTTP/1.1
Host: localhost:5000
```

**쿼리 파라미터 (선택적):**
- `status`: 특정 상태의 주문만 조회 (예: `?status=received,inProgress`)
- `limit`: 조회할 주문 수 (기본값: 50)
- `offset`: 페이지네이션 오프셋 (기본값: 0)

**응답 (200 OK):**
```json
{
  "success": true,
  "data": [
    {
      "orderId": 15,
      "totalAmount": 14000,
      "status": "received",
      "items": [
        {
          "menuName": "아메리카노 (ICE)",
          "quantity": 2
        },
        {
          "menuName": "카페라떼",
          "quantity": 1
        }
      ],
      "createdAt": "2025-11-12T14:30:00.000Z"
    },
    {
      "orderId": 14,
      "totalAmount": 5000,
      "status": "inProgress",
      "items": [
        {
          "menuName": "카페라떼",
          "quantity": 1
        }
      ],
      "createdAt": "2025-11-12T14:00:00.000Z"
    }
  ]
}
```

**SQL 쿼리:**
```sql
-- 주문 목록 조회
SELECT order_id, total_amount, status, created_at
FROM orders
ORDER BY created_at DESC
LIMIT $1 OFFSET $2;

-- 각 주문의 아이템 조회
SELECT 
  oi.order_id,
  m.name as menu_name,
  oi.quantity
FROM order_items oi
JOIN menus m ON oi.menu_id = m.menu_id
WHERE oi.order_id IN (15, 14, ...);
```

##### 9. PATCH /api/admin/orders/:orderId/status
주문 상태를 변경합니다.

**요청:**
```http
PATCH /api/admin/orders/15/status HTTP/1.1
Host: localhost:5000
Content-Type: application/json

{
  "status": "inProgress"
}
```

**요청 본문 검증:**
- `status`: 문자열, 필수
- 허용 값: `received`, `inProgress`, `completed`
- 상태 전환 규칙:
  - `pending` → `received`
  - `received` → `inProgress`
  - `inProgress` → `completed`

**응답 (200 OK):**
```json
{
  "success": true,
  "data": {
    "orderId": 15,
    "status": "inProgress",
    "updatedAt": "2025-11-12T14:35:00.000Z"
  }
}
```

**에러 응답 (400):**
```json
{
  "success": false,
  "error": "유효하지 않은 상태 전환입니다",
  "details": {
    "currentStatus": "completed",
    "requestedStatus": "inProgress"
  }
}
```

**에러 응답 (404):**
```json
{
  "success": false,
  "error": "주문을 찾을 수 없습니다"
}
```

**비즈니스 로직:**
1. 현재 주문 상태 조회
2. 요청된 상태로 전환 가능한지 검증
3. 상태 업데이트 및 `updated_at` 갱신

**SQL 쿼리:**
```sql
-- 현재 상태 조회
SELECT status
FROM orders
WHERE order_id = $1;

-- 상태 업데이트
UPDATE orders
SET status = $1, updated_at = NOW()
WHERE order_id = $2
RETURNING order_id, status, updated_at;
```

### 8.5 에러 처리 및 검증

#### 8.5.1 HTTP 상태 코드
- `200 OK`: 성공적인 조회/수정
- `201 Created`: 성공적인 생성
- `400 Bad Request`: 잘못된 요청 (검증 실패)
- `404 Not Found`: 리소스를 찾을 수 없음
- `500 Internal Server Error`: 서버 내부 오류

#### 8.5.2 에러 응답 형식
모든 에러 응답은 다음 형식을 따릅니다:

```json
{
  "success": false,
  "error": "사용자에게 표시할 에러 메시지",
  "details": {
    // 선택적: 추가 에러 정보
  }
}
```

#### 8.5.3 입력 검증
모든 API 엔드포인트는 다음을 검증해야 합니다:
- 필수 필드 존재 여부
- 데이터 타입 (정수, 문자열, 배열 등)
- 값의 범위 (예: 수량은 1 이상)
- 외래키 유효성 (존재하는 ID인지)

#### 8.5.4 데이터베이스 제약 조건
```sql
-- 가격과 수량은 음수 불가
CHECK (price >= 0)
CHECK (stock >= 0)
CHECK (quantity > 0)

-- 주문 상태는 정해진 값만 허용
CHECK (status IN ('pending', 'received', 'inProgress', 'completed'))

-- 외래키 제약
REFERENCES menus(menu_id) ON DELETE CASCADE
REFERENCES orders(order_id) ON DELETE CASCADE
```

### 8.6 성능 최적화

#### 8.6.1 데이터베이스 인덱스
```sql
-- 주문 상태로 자주 조회
CREATE INDEX idx_orders_status ON orders(status);

-- 최신 주문순 정렬
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);

-- 주문 아이템 조인 최적화
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_menu_id ON order_items(menu_id);

-- 옵션 조회 최적화
CREATE INDEX idx_options_menu_id ON options(menu_id);
CREATE INDEX idx_order_item_options_item_id ON order_item_options(item_id);

-- 재고 필터링
CREATE INDEX idx_menus_stock ON menus(stock);
```

#### 8.6.2 커넥션 풀
```javascript
// config/database.js
const { Pool } = require('pg');

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT || 5432,
  max: 20, // 최대 커넥션 수
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000
});

module.exports = pool;
```

#### 8.6.3 트랜잭션 관리
주문 생성 시 반드시 트랜잭션을 사용하여 데이터 일관성을 보장합니다.

```javascript
const client = await pool.connect();
try {
  await client.query('BEGIN');
  
  // 재고 확인 (FOR UPDATE 락)
  const stockResult = await client.query(
    'SELECT stock FROM menus WHERE menu_id = $1 FOR UPDATE',
    [menuId]
  );
  
  if (stockResult.rows[0].stock < quantity) {
    throw new Error('재고 부족');
  }
  
  // 주문 생성
  // 아이템 추가
  // 재고 차감
  
  await client.query('COMMIT');
} catch (err) {
  await client.query('ROLLBACK');
  throw err;
} finally {
  client.release();
}
```

### 8.7 보안 고려사항

#### 8.7.1 SQL 인젝션 방지
모든 쿼리는 파라미터화된 쿼리 사용:
```javascript
// ❌ 위험
const result = await pool.query(
  `SELECT * FROM menus WHERE menu_id = ${req.params.id}`
);

// ✅ 안전
const result = await pool.query(
  'SELECT * FROM menus WHERE menu_id = $1',
  [req.params.id]
);
```

#### 8.7.2 CORS 설정
```javascript
const cors = require('cors');

app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
```

#### 8.7.3 환경 변수
민감한 정보는 `.env` 파일로 관리:
```
DB_HOST=localhost
DB_PORT=5432
DB_NAME=coffee_order
DB_USER=postgres
DB_PASSWORD=your_password
PORT=5000
FRONTEND_URL=http://localhost:3000
```

### 8.8 테스트 가이드

#### 8.8.1 단위 테스트 (선택적)
- 각 컨트롤러 함수 테스트
- 입력 검증 로직 테스트
- 금액 계산 로직 테스트

#### 8.8.2 통합 테스트 (선택적)
- API 엔드포인트 전체 흐름 테스트
- 데이터베이스 트랜잭션 테스트
- 에러 처리 테스트

#### 8.8.3 수동 테스트
Postman 또는 Thunder Client로 각 API 테스트:
1. 메뉴 조회
2. 주문 생성 (정상 케이스)
3. 주문 생성 (재고 부족)
4. 재고 수정
5. 주문 상태 변경

### 8.9 배포 고려사항

#### 8.9.1 환경 구성
- 개발: `localhost`
- 프로덕션: 실제 서버 (Heroku, AWS, DigitalOcean 등)

#### 8.9.2 데이터베이스 마이그레이션
1. 초기 스키마 생성 SQL 파일 작성
2. 시드 데이터 SQL 파일 작성
3. 배포 시 순서대로 실행

#### 8.9.3 로깅
```javascript
// 요청 로깅
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} ${req.method} ${req.path}`);
  next();
});

// 에러 로깅
app.use((err, req, res, next) => {
  console.error(`Error: ${err.message}`);
  console.error(err.stack);
  res.status(500).json({
    success: false,
    error: '서버 오류가 발생했습니다'
  });
});
```

### 8.10 개발 우선순위

#### Phase 1: 기본 API (1주)
1. ✅ 데이터베이스 스키마 생성
2. ✅ 메뉴 조회 API (`GET /api/menus`)
3. ✅ 주문 생성 API (`POST /api/orders`)
4. ✅ 재고 차감 로직

#### Phase 2: 관리자 API (1주)
1. ✅ 주문 목록 조회 (`GET /api/admin/orders`)
2. ✅ 주문 상태 변경 (`PATCH /api/admin/orders/:id/status`)
3. ✅ 재고 조회 (`GET /api/admin/inventory`)
4. ✅ 재고 수정 (`PATCH /api/admin/inventory/:id`)
5. ✅ 통계 조회 (`GET /api/admin/statistics`)

#### Phase 3: 최적화 및 테스트 (선택적)
1. 에러 처리 강화
2. 입력 검증 미들웨어
3. API 테스트
4. 성능 최적화

---

## 9. 프론트엔드-백엔드 통합 가이드

### 9.1 API 서비스 레이어 활용
프론트엔드의 `src/services/api.js` 파일을 실제 백엔드 엔드포인트로 연결:

```javascript
// src/services/api.js
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000';

export const menuApi = {
  // 메뉴 목록 조회
  getMenus: async () => {
    const response = await fetch(`${API_URL}/api/menus`);
    if (!response.ok) throw new Error('메뉴를 불러올 수 없습니다');
    const data = await response.json();
    return data.data; // { success: true, data: [...] }
  }
};

export const orderApi = {
  // 주문 생성
  createOrder: async (orderData) => {
    const response = await fetch(`${API_URL}/api/orders`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(orderData)
    });
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || '주문에 실패했습니다');
    }
    const data = await response.json();
    return data.data;
  }
};
```

### 9.2 환경 변수 설정
```
# ui/.env
VITE_API_URL=http://localhost:5000
```

### 9.3 CORS 이슈 해결
백엔드에서 CORS 미들웨어 설정:
```javascript
// server/src/app.js
const cors = require('cors');
app.use(cors({
  origin: 'http://localhost:3000'
}));
```

---

## 10. 부록

### 10.1 데이터베이스 초기화 스크립트

```sql
-- schema.sql
-- 기존 테이블 삭제 (개발 환경에서만)
DROP TABLE IF EXISTS order_item_options CASCADE;
DROP TABLE IF EXISTS order_items CASCADE;
DROP TABLE IF EXISTS orders CASCADE;
DROP TABLE IF EXISTS options CASCADE;
DROP TABLE IF EXISTS menus CASCADE;

-- 테이블 생성
CREATE TABLE menus (
  menu_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  price INTEGER NOT NULL CHECK (price >= 0),
  image_url VARCHAR(500),
  stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE options (
  option_id SERIAL PRIMARY KEY,
  menu_id INTEGER NOT NULL REFERENCES menus(menu_id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  price INTEGER NOT NULL DEFAULT 0 CHECK (price >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  total_amount INTEGER NOT NULL CHECK (total_amount >= 0),
  status VARCHAR(20) NOT NULL DEFAULT 'pending' 
    CHECK (status IN ('pending', 'received', 'inProgress', 'completed')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_items (
  item_id SERIAL PRIMARY KEY,
  order_id INTEGER NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
  menu_id INTEGER NOT NULL REFERENCES menus(menu_id),
  quantity INTEGER NOT NULL CHECK (quantity > 0),
  price INTEGER NOT NULL CHECK (price >= 0),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE order_item_options (
  id SERIAL PRIMARY KEY,
  item_id INTEGER NOT NULL REFERENCES order_items(item_id) ON DELETE CASCADE,
  option_id INTEGER NOT NULL REFERENCES options(option_id),
  option_name VARCHAR(50) NOT NULL,
  option_price INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스 생성
CREATE INDEX idx_menus_stock ON menus(stock);
CREATE INDEX idx_options_menu_id ON options(menu_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
CREATE INDEX idx_order_items_menu_id ON order_items(menu_id);
CREATE INDEX idx_order_item_options_item_id ON order_item_options(item_id);
```

### 10.2 시드 데이터 스크립트

```sql
-- seed.sql
-- 메뉴 추가
INSERT INTO menus (name, description, price, image_url, stock) VALUES
('아메리카노 (ICE)', '깔끔하고 시원한 아이스 아메리카노', 4000, 'https://images.unsplash.com/photo-1461023058943-07fcbe16d735', 20),
('아메리카노 (HOT)', '따뜻하고 진한 핫 아메리카노', 4000, 'https://images.unsplash.com/photo-1514432324607-a09d9b4aefdd', 20),
('카페라떼', '부드러운 우유와 에스프레소의 조화', 5000, 'https://images.unsplash.com/photo-1561882468-9110e03e0f78', 15);

-- 옵션 추가
INSERT INTO options (menu_id, name, price) VALUES
-- 아메리카노 (ICE)
(1, '샷 추가', 500),
(1, '시럽 추가', 500),
-- 아메리카노 (HOT)
(2, '샷 추가', 500),
(2, '시럽 추가', 500),
-- 카페라떼
(3, '샷 추가', 500),
(3, '바닐라 시럽', 500),
(3, '헤이즐넛 시럽', 500);
```

### 10.3 package.json 예시

```json
{
  "name": "coffee-order-backend",
  "version": "1.0.0",
  "description": "Coffee Order App Backend API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "db:init": "psql -U postgres -d coffee_order -f schema.sql",
    "db:seed": "psql -U postgres -d coffee_order -f seed.sql"
  },
  "dependencies": {
    "express": "^4.18.2",
    "pg": "^8.11.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

---

## 9. 구현 완료 및 배포 가이드

### 9.1 구현 완료 상태 (2025-11-12)

#### 9.1.1 완료된 기능
✅ **프론트엔드 (React + Vite)**
- 주문 페이지: 메뉴 선택, 옵션 추가, 장바구니, 주문 생성
- 관리자 페이지: 통계 대시보드, 재고 관리, 주문 상태 관리
- 실시간 재고 표시 (10개 이하 주황색, 0개 빨간색)
- 주문 상태별 구분 (접수된 주문 / 제조중인 주문)
- 반응형 UI (커피 테마 디자인)

✅ **백엔드 (Node.js + Express + PostgreSQL)**
- RESTful API 9개 엔드포인트 구현
- 트랜잭션 기반 주문 처리 (재고 차감 자동화)
- 주문 상태 관리 (received → inProgress → completed)
- CORS 설정, 에러 핸들링, 입력 검증
- UTF-8 한글 완벽 지원

✅ **데이터베이스 (PostgreSQL)**
- 5개 테이블 (menus, options, orders, order_items, order_item_options)
- 7개 인덱스 (성능 최적화)
- 자동 타임스탬프 업데이트 트리거
- 외래키 제약조건 및 참조 무결성

#### 9.1.2 기술 스택 최종 버전
```json
{
  "frontend": {
    "framework": "React 18.3.1",
    "buildTool": "Vite 5.4.21",
    "routing": "React Router DOM 6.26.0",
    "devServer": "http://localhost:3000"
  },
  "backend": {
    "runtime": "Node.js 22.x",
    "framework": "Express 4.18.2",
    "database": "PostgreSQL 14+",
    "dbClient": "pg 8.11.0",
    "devServer": "http://localhost:5000"
  }
}
```

### 9.2 중요 설정 및 해결된 이슈

#### 9.2.1 PostgreSQL UTF-8 인코딩 설정
**문제:** Windows 환경에서 한글이 ???로 깨지는 현상
**해결방법:**
```sql
-- 데이터베이스 생성 시 UTF-8 인코딩 명시
CREATE DATABASE coffee_order_db 
WITH ENCODING='UTF8' 
LC_COLLATE='C' 
LC_CTYPE='C' 
TEMPLATE=template0;
```

**데이터 삽입 시:**
```powershell
# PowerShell에서 UTF-8 환경 설정
$env:PGCLIENTENCODING='UTF8'
$env:PGPASSWORD='your_password'
psql -U postgres -d coffee_order_db -f database/seed_korean.sql
```

#### 9.2.2 Express UTF-8 응답 설정
```javascript
// src/app.js
app.use((req, res, next) => {
  res.setHeader('Content-Type', 'application/json; charset=utf-8');
  next();
});

// src/config/database.js
const pool = new Pool({
  // ...기타 설정
  client_encoding: 'UTF8'
});
```

#### 9.2.3 서버 실행 명령어
```powershell
# 백엔드 서버 (터미널 1)
cd I:\Cursor_test\oder-app-vscode\server
npm run dev

# 프론트엔드 서버 (터미널 2)
cd I:\Cursor_test\oder-app-vscode\ui
npm run dev
```

**서버 상태 확인:**
```powershell
# 포트 사용 확인
netstat -ano | findstr ":3000 :5000"

# Node 프로세스 전체 종료 (문제 발생 시)
taskkill /F /IM node.exe
```

### 9.3 데이터베이스 초기화 절차

#### 9.3.1 데이터베이스 생성
```powershell
cd server
$psqlPath = (Get-ChildItem "C:\Program Files\PostgreSQL\*\bin\psql.exe")[0].FullName
$env:PGPASSWORD='7337'

# 기존 DB 삭제 및 재생성
& $psqlPath -U postgres -c "DROP DATABASE IF EXISTS coffee_order_db;"
& $psqlPath -U postgres -c "CREATE DATABASE coffee_order_db WITH ENCODING='UTF8' LC_COLLATE='C' LC_CTYPE='C' TEMPLATE=template0;"
```

#### 9.3.2 스키마 및 데이터 삽입
```powershell
# 스키마 생성
$env:PGCLIENTENCODING='UTF8'
Get-Content "database\schema.sql" -Raw | & $psqlPath -U postgres -d coffee_order_db

# 한글 데이터 삽입
& $psqlPath -U postgres -d coffee_order_db -f database\seed_korean.sql
```

### 9.4 API 엔드포인트 목록

#### 9.4.1 메뉴 관련
- `GET /api/menus` - 전체 메뉴 및 옵션 조회
- `GET /api/menus/:menuId` - 특정 메뉴 상세 조회

#### 9.4.2 주문 관련
- `POST /api/orders` - 주문 생성 (재고 차감 포함)
- `GET /api/orders/:orderId` - 주문 상세 조회

#### 9.4.3 관리자 관련
- `GET /api/admin/statistics` - 주문 통계 조회
- `GET /api/admin/inventory` - 재고 목록 조회
- `PATCH /api/admin/inventory/:menuId` - 재고 수정
- `GET /api/admin/orders` - 주문 목록 조회 (상태별 필터)
- `PATCH /api/admin/orders/:orderId/status` - 주문 상태 변경

### 9.5 프로젝트 구조
```
oder-app-vscode/
├── docs/
│   └── PRD.md                    # 본 문서
├── server/                       # 백엔드
│   ├── database/
│   │   ├── schema.sql           # DB 스키마
│   │   ├── seed.sql             # 영문 시드 데이터
│   │   └── seed_korean.sql      # 한글 시드 데이터 (사용중)
│   ├── src/
│   │   ├── config/
│   │   │   └── database.js      # PostgreSQL 연결 풀
│   │   ├── controllers/
│   │   │   ├── menuController.js
│   │   │   ├── orderController.js
│   │   │   └── adminController.js
│   │   ├── routes/
│   │   │   ├── menus.js
│   │   │   ├── orders.js
│   │   │   └── admin.js
│   │   ├── middleware/
│   │   │   ├── errorHandler.js
│   │   │   └── validator.js
│   │   └── app.js               # Express 앱 설정
│   ├── .env                      # 환경 변수 (DB 비밀번호)
│   ├── .gitignore
│   ├── package.json
│   └── server.js                 # 서버 엔트리포인트
├── ui/                           # 프론트엔드
│   ├── src/
│   │   ├── pages/
│   │   │   ├── OrderPage.jsx    # 주문 페이지
│   │   │   ├── OrderPage.css
│   │   │   ├── AdminPage.jsx    # 관리자 페이지
│   │   │   └── AdminPage.css
│   │   ├── services/
│   │   │   └── api.js           # API 호출 함수
│   │   ├── App.jsx              # 라우팅 설정
│   │   ├── App.css
│   │   └── main.jsx
│   ├── index.html
│   ├── package.json
│   └── vite.config.js
└── .git/
```

### 9.6 환경 변수 설정

**server/.env**
```env
# 데이터베이스 설정
DB_HOST=localhost
DB_PORT=5432
DB_NAME=coffee_order_db
DB_USER=postgres
DB_PASSWORD=7337

# 서버 설정
PORT=5000
NODE_ENV=development
FRONTEND_URL=http://localhost:3000
```

### 9.7 알려진 제한사항 및 향후 개선 사항

#### 9.7.1 현재 제한사항
- 사용자 인증 없음 (누구나 관리자 페이지 접근 가능)
- 결제 기능 없음
- 이미지는 외부 URL 사용 (Unsplash)
- 실시간 알림 없음 (새로고침 필요)

#### 9.7.2 향후 개선 가능 항목
- [ ] 관리자 로그인 인증 추가
- [ ] 주문 완료 시 알림 기능 (WebSocket)
- [ ] 주문 내역 페이지
- [ ] 메뉴 이미지 업로드 기능
- [ ] 판매 통계 차트
- [ ] 주문 취소 기능
- [ ] 프린터 연동 (주문서 출력)

### 9.8 트러블슈팅 가이드

#### 9.8.1 한글 깨짐 현상
**증상:** 메뉴 이름이 ???로 표시됨
**해결:**
1. 데이터베이스 재생성 (섹션 9.3 참조)
2. seed_korean.sql 파일로 데이터 재삽입
3. 브라우저 캐시 삭제 후 Ctrl+Shift+R

#### 9.8.2 서버 실행 안됨
**증상:** npm run dev 시 에러
**해결:**
```powershell
# 1. 모든 Node 프로세스 종료
taskkill /F /IM node.exe

# 2. node_modules 재설치
cd server
rm -r node_modules
npm install

# 3. 서버 재시작
npm run dev
```

#### 9.8.3 포트 충돌
**증상:** EADDRINUSE 에러
**해결:**
```powershell
# 포트 사용 프로세스 확인
netstat -ano | findstr ":5000"

# 프로세스 강제 종료 (PID는 위 명령어 결과에서 확인)
taskkill /F /PID <프로세스ID>
```

---

**마지막 업데이트:** 2025-11-12
**작성자:** AI Assistant with User
**상태:** ✅ 구현 완료 및 테스트 완료